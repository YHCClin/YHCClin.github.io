<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="description" content="还没有整理过的笔记，有点乱">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="侯捷C++学习笔记[未整理版]">
<meta property="og:url" content="https://www.ccyh.xyz/p/6c8e.html">
<meta property="og:site_name" content="Liam&#39;s Blog">
<meta property="og:description" content="还没有整理过的笔记，有点乱">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr2.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/templateMethod.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/db.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/new.png">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/overideDelete.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride%5B%5D.jpg">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foo.png">
<meta property="og:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foowithvirtual.png">
<meta property="og:updated_time" content="2020-03-23T04:59:32.939Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="侯捷C++学习笔记[未整理版]">
<meta name="twitter:description" content="还没有整理过的笔记，有点乱">
<meta name="twitter:image" content="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr.jpg"><meta name="keywords" content="Liam, Liam's Blog"><meta name="description" content="Algorithms"><title>侯捷C++学习笔记[未整理版]</title><link ref="canonical" href="/p/6c8e.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Liam's Blog</div><div class="header-banner-info__subtitle">Liam's blog</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">侯捷C++学习笔记[未整理版]</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-03-23</span></span></div></header><div class="post-body"><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>还没有整理过的笔记，有点乱</p>
</blockquote>
<a id="more"></a>

        <h1 id="C-程序设计II-兼谈对象模型">
          <a href="#C-程序设计II-兼谈对象模型" class="heading-link"><i class="fas fa-link"></i></a>C++ 程序设计II 兼谈对象模型</h1>
      <hr>

        <h2 id="Conversion-function-转换函数-operator-type">
          <a href="#Conversion-function-转换函数-operator-type" class="heading-link"><i class="fas fa-link"></i></a>Conversion function - 转换函数 operator type()</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this type -&gt; other type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span> <span class="comment">// 分数类，分数可以被看成double</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// 最好加const </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="comment">// 转换函数，不唯一，合理就行</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_denominator; <span class="comment">// 分母</span></span><br><span class="line">        <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">4</span> + f; <span class="comment">// 调用 operator double() 将 f 转换成 double</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="non-explicit-one-argument-ctor">
          <a href="#non-explicit-one-argument-ctor" class="heading-link"><i class="fas fa-link"></i></a>non-explicit-one-argument ctor</h2>
      <hr>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other type -&gt; this type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span> <span class="comment">// 分数类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-explicit-one-argument constructor</span></span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当下面operator type() 函数同时存在时，会迷惑编译器，出错 ambiguous</span></span><br><span class="line"><span class="comment">    // 因为有两条路可行：</span></span><br><span class="line"><span class="comment">        1. 将 4 转Fraction</span></span><br><span class="line"><span class="comment">        2. 将 f 转double 在将 4.6 转Fraction</span></span><br><span class="line"><span class="comment">        从而产生歧义</span></span><br><span class="line"><span class="comment">    operator double() const // 最好加const </span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return ((double)m_numerator / m_denominator);</span></span><br><span class="line"><span class="comment">    &#125; // 转换函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_denominator; <span class="comment">// 分母</span></span><br><span class="line">        <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="number">4</span> + f; <span class="comment">// 调用 non-explicit ctor 将 4 转换成 Fraction,然后调用operator+()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="explicit-one-argument-ctor">
          <a href="#explicit-one-argument-ctor" class="heading-link"><i class="fas fa-link"></i></a>explicit-one-argument ctor</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other type -&gt; this type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span> <span class="comment">// 分数类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// explicit-one-argument constructor</span></span><br><span class="line">    explicit Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) &#123;&#125; // 90% 的 explicit 用在构造函数上</span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// 最好加const </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="comment">// 转换函数</span></span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_denominator; <span class="comment">// 分母</span></span><br><span class="line">        <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="number">4</span> + f; <span class="comment">// [Error] conversion from double to Fraction requested, 4 不能自动转为Fraction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="应用">
          <a href="#应用" class="heading-link"><i class="fas fa-link"></i></a>应用</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool, Alloc&gt; &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> __bit_reference reference;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(begin() + defference_type(n));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> !(!(*p &amp; mask)); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="pointer-like-classes-关于智能指针">
          <a href="#pointer-like-classes-关于智能指针" class="heading-link"><i class="fas fa-link"></i></a>pointer-like classes, 关于智能指针</h2>
      <hr>
<blockquote>
<blockquote>
<p>一个 class 产生出来的对象像一个指针(do more then pointer, such as auto pointer)</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 固定写法</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *px;&#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> px;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">shared_ptr</span>(T* p) : px(px) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T*    px; <span class="comment">// 指向 T 的指针</span></span><br><span class="line">        <span class="keyword">long</span>* pn;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; sp(<span class="keyword">new</span> Foo); <span class="comment">// 初始化sp为指向Foo的智能指针,即sp内部的px指向Foo</span></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>; <span class="comment">// *p 调用 operator*()</span></span><br><span class="line">    sp -&gt; method(); <span class="comment">// 调用 method 函数 等价于 调用operator-&gt;() 再调用 px -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="pointer-like-classes-关于迭代器-一种特别的智能指针">
          <a href="#pointer-like-classes-关于迭代器-一种特别的智能指针" class="heading-link"><i class="fas fa-link"></i></a>pointer-like classes, 关于迭代器(一种特别的智能指针)</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list 链表节点设计</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* prev;</span><br><span class="line">    <span class="keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;lass T, <span class="class"><span class="keyword">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span> <span class="comment">// 链表的迭代器实现</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type; <span class="comment">// 指向链表节点的指针类型</span></span><br><span class="line">    link_type node; <span class="comment">// node 为指向链表节点的指针</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node != x.node;&#125;</span><br><span class="line">    <span class="comment">// 本节重点</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;<span class="comment">//前置</span></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;<span class="comment">//后置</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;<span class="comment">//前置</span></span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; --*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;<span class="comment">//后置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;Foo&gt;::iterator it;</span><br><span class="line">    *it; <span class="comment">// 获得一个Foo对象</span></span><br><span class="line">    it -&gt; method();</span><br><span class="line">    <span class="comment">// 调用Foo::method()</span></span><br><span class="line">    <span class="comment">// 相当于 (*it).method();</span></span><br><span class="line">    <span class="comment">// 相当于 (&amp;(*it)) -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="function-like-classes-所谓-仿函数-像函数的类">
          <a href="#function-like-classes-所谓-仿函数-像函数的类" class="heading-link"><i class="fas fa-link"></i></a>function-like classes, 所谓 仿函数 (像函数的类)</h2>
      <blockquote>
<blockquote>
<p>() 函数调用操作符 function call<br>一般只要看到class内重载了()操作符，那他的用意就是想要变成一个function,其构造的对象称为函数对象<br>标准库中，仿函数会继承一些奇特的基类如：unary_function , binary_function</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为零</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> T&amp;</span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> T&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x;&#125; <span class="comment">// 重载了函数调用操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt; // 源代码暗示你给他一个 <span class="title">pair</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, typname Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp;</span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x.first;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, typname Pair::second_type&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type&amp;</span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x.second;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="comment">// 传参初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; p(<span class="string">'a'</span>,<span class="number">97</span>);</span><br><span class="line">    <span class="keyword">char</span> ch = select1st(p);</span><br><span class="line">    <span class="keyword">int</span> in  = select2nd(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="namespase-经验谈">
          <a href="#namespase-经验谈" class="heading-link"><i class="fas fa-link"></i></a>namespase 经验谈</h2>
      <hr>
<blockquote>
<blockquote>
<p>避免命名冲突</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj01 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_member_template</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">namespase jj02 &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> Lst = <span class="built_in">list</span>&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_template_param</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"><span class="comment">// 可以将所有测试函数放在一个main里面执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    jj01::test_member_template();</span><br><span class="line">    jj02::test_template_param();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="class-template-模板类-泛型编程">
          <a href="#class-template-模板类-泛型编程" class="heading-link"><i class="fas fa-link"></i></a>class template, 模板类(泛型编程)</h2>
      <hr>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line">    T a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">getA</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="function-template-函数模板">
          <a href="#function-template-函数模板" class="heading-link"><i class="fas fa-link"></i></a>function template, 函数模板</h2>
      <blockquote>
<blockquote>
<p>编译器会对 function template 进行 实参推导 (augument deduction)</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stone</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stone (<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> we)</span><br><span class="line">    : _w(w), _h(h), _weight(we) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> stone&amp; ths) <span class="keyword">const</span> &#123;<span class="keyword">return</span> _weight &lt; rhs._weight;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _w, _h, _weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">min</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a; <span class="comment">// 实参推导的结果，T 为stone，于是调用 stone::operator&lt;()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="member-template-成员模板-令构造函数更有弹性">
          <a href="#member-template-成员模板-令构造函数更有弹性" class="heading-link"><i class="fas fa-link"></i></a>member template, 成员模板(令构造函数更有弹性)</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="comment">// 传参初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员模板(是成员又是模板)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;U1, U2&gt;&amp; <span class="title">p</span>) // 构造函数 <span class="title">U1</span>,<span class="title">U2</span> 必须(可转型为)继承于 <span class="title">T1</span>,<span class="title">T2</span></span></span><br><span class="line"><span class="class">    :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h4 id="例子">
          <a href="#例子" class="heading-link"><i class="fas fa-link"></i></a>例子:</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p); <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; b;</span><br><span class="line">pair&lt;Derived1, Derived2&gt; b2(b); <span class="comment">// 不可以</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1; <span class="comment">// up-cast 向上造型</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Base1&gt; sptr(<span class="keyword">new</span>  Derived1); <span class="comment">// 模拟up-cast</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="specialization-模板特化">
          <a href="#specialization-模板特化" class="heading-link"><i class="fas fa-link"></i></a>specialization, 模板特化</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt; // 绑定</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>() (<span class="keyword">char</span> x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>() (<span class="keyword">int</span> x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hash&lt;<span class="keyword">int</span>&gt; () (<span class="number">1000</span>); <span class="comment">// 临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="partial-specialization-模板偏特化-–-个数上的偏">
          <a href="#partial-specialization-模板偏特化-–-个数上的偏" class="heading-link"><i class="fas fa-link"></i></a>partial specialization, 模板偏特化 – 个数上的偏</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = ...&gt;</span><br><span class="line">class <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Alloc&gt; <span class="comment">// 绑定第一个模板参数，必须从左到右依次指定，不可跳跃</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------</span></span><br><span class="line"><span class="comment">// 范围上的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></div></figure>

        <h2 id="template-template-parameter-模板模板参数">
          <a href="#template-template-parameter-模板模板参数" class="heading-link"><i class="fas fa-link"></i></a>template template parameter, 模板模板参数</h2>
      <hr>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Container为模板模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">XCls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = <span class="built_in">list</span>&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="built_in">string</span>, <span class="built_in">list</span>&gt; my1st1; <span class="comment">// Error list本身是模板，未定义</span></span><br><span class="line">XCls&lt;<span class="built_in">string</span>, Lst&gt; my1st2; <span class="comment">// 可以</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">SmatPtr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">XCls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SmatPtr&lt;T&gt; sp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    XCls() : sp(<span class="keyword">new</span> T) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="built_in">string</span>, <span class="built_in">shared_ptr</span>&gt; p1; <span class="comment">// ok</span></span><br><span class="line">XCls&lt;<span class="built_in">string</span>, <span class="built_in">unique_ptr</span>&gt; p2; <span class="comment">// no</span></span><br><span class="line">XCls&lt;<span class="built_in">string</span>, weak_ptr&gt; p3; <span class="comment">// no</span></span><br><span class="line">XCls&lt;<span class="built_in">string</span>, <span class="built_in">auto_ptr</span>&gt; p4; <span class="comment">// ok</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="这个不是-template-template-parameter">
          <a href="#这个不是-template-template-parameter" class="heading-link"><i class="fas fa-link"></i></a>这个不是 template template parameter</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    pass</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; s2; <span class="comment">// 已经指定list&lt;int&gt;</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="关于-C-标准库">
          <a href="#关于-C-标准库" class="heading-link"><i class="fas fa-link"></i></a>关于 C++ 标准库</h2>
      <hr>
<blockquote>
<blockquote>
<p>Iterator   迭代器<br>Container  容器<br>Algorithm  算法<br>Functors   仿函数</p>
</blockquote>
</blockquote>
<p>查看标准库，并实验每一个已经实现的标准库功能。</p>
<hr>

        <h1 id="C-11-新特性">
          <a href="#C-11-新特性" class="heading-link"><i class="fas fa-link"></i></a>C++11 新特性</h1>
      <hr>

        <h2 id="variadic-templates-数量不定的模板参数-since-C-11">
          <a href="#variadic-templates-数量不定的模板参数-since-C-11" class="heading-link"><i class="fas fa-link"></i></a>variadic templates  数量不定的模板参数 (since C++11)</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt; <span class="comment">// ... 也是语法的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &lt;&lt; 须重载</span></span><br><span class="line">    print(args...); <span class="comment">// 递归调用，每次分为firstArg和后面 Types... (其他的多个)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">print(<span class="number">7.5</span>, <span class="string">"hello"</span>, <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">337</span>), <span class="number">42</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.5</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">0000000101111001</span></span><br><span class="line"><span class="comment">42</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 sizeof(args...) 可以得到后面一包是几个</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="auto-语法糖-since-c-11">
          <a href="#auto-语法糖-since-c-11" class="heading-link"><i class="fas fa-link"></i></a>auto 语法糖(since c++11)</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">auto</span> ite = find(c.begin(), c.end(), target); </span><br><span class="line"><span class="comment">// 让编译器自动帮你推断类型，但前提是你得有assign语句，不然编译器不知道怎么推</span></span><br><span class="line"><span class="keyword">auto</span> it; <span class="comment">// 不能这样写，编译器不知道it是什么类型</span></span><br><span class="line">it = find(c.begin(), c.end(),target); <span class="comment">// 错误</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="range-base-for-语法糖-since-C-11">
          <a href="#range-base-for-语法糖-since-C-11" class="heading-link"><i class="fas fa-link"></i></a>range-base for 语法糖(since C++11)</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : container) <span class="comment">// 逐个取出，copy到 i 上 (pass by value)</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : container) <span class="comment">// pass by reference 更改了container 中的值</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;) <span class="comment">// 新语法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="reference-引用-代表-实际上是指针实现的">
          <a href="#reference-引用-代表-实际上是指针实现的" class="heading-link"><i class="fas fa-link"></i></a>reference 引用(代表),实际上是指针实现的</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;x; <span class="comment">// p pointer to x</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = x;  <span class="comment">// r reference to x , r 代表 x, r 从一而终，不能再代表其它对象了</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器制造的假象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(r) == <span class="keyword">sizeof</span>(x)) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true 但其实 r 是一个指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (&amp;r == &amp;x) &lt;&lt; <span class="built_in">endl</span>;               <span class="comment">// true 假象</span></span><br><span class="line"></span><br><span class="line">r = x2;      <span class="comment">// r 不能从新代表其它对象，只是把 r 代表的 x 的值变成 x2 的值罢了</span></span><br><span class="line"><span class="keyword">int</span>&amp; r2 = r; <span class="comment">// r2 reference to r (r2 代表 r, 亦相当于代表 x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管是内置类型还是自定义类型都符合上述结论</span></span><br></pre></td></tr></table></div></figure>
<blockquote>
<blockquote>
<p>reference 通常不用于声明变量，而用于参数类型(parameter type)和返回类型(return type)的描述.</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(T *pobj)</span> </span>&#123;pobj -&gt; xxx();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(T pobj)</span> </span>&#123;pobj.xxx();&#125; <span class="comment">// 须拷贝，传递较慢</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(T&amp; pobj)</span> </span>&#123;pobj.xxx();&#125;</span><br><span class="line"></span><br><span class="line">T obj;</span><br><span class="line">func1(&amp;obj);<span class="comment">// 调用接口不同，困扰</span></span><br><span class="line">func2(obj); <span class="comment">// 调用接口相同，很好</span></span><br><span class="line">func3(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意，写函数重载时，以下两种(same signature)不能并存</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span></span>; <span class="comment">// Ambiguous</span></span><br></pre></td></tr></table></div></figure>
<blockquote>
<blockquote>
<p>Q : const 是不是函数签名的一部分，即是否能作为重载的指标？<br>A : 是！</p>
</blockquote>
</blockquote>

        <h1 id="Object-Model-对象模型">
          <a href="#Object-Model-对象模型" class="heading-link"><i class="fas fa-link"></i></a>Object Model 对象模型</h1>
      <hr>

        <h2 id="Part-I-的承接">
          <a href="#Part-I-的承接" class="heading-link"><i class="fas fa-link"></i></a>Part I 的承接</h2>
      <blockquote>
<blockquote>
<p>Inheritance 继承：           构造由内而外，析构由外而内<br>Composition 复合：           构造由内而外，析构由外而内<br>Inheritance+Composition：    构造由内而外，析构由外而内</p>
<blockquote>
<p>Derived::Derived(…) : Base(),Component() {…}<br>Derived::~Derived() {… Component(); Base()} // 与构造相反</p>
</blockquote>
</blockquote>
</blockquote>

        <h2 id="关于-vptr-和-vtbl-虚指针和虚表">
          <a href="#关于-vptr-和-vtbl-虚指针和虚表" class="heading-link"><i class="fas fa-link"></i></a>关于 vptr 和 vtbl (虚指针和虚表)</h2>
      <blockquote>
<blockquote>
<p>只要类中有虚函数，其对象在内存中就会多一根指针（指向虚表）<br>父类有虚函数，子类对象也一定拥有该指针</p>
</blockquote>
</blockquote>
<hr>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>; <span class="comment">// override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>; <span class="comment">// override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="内存模型：-动态绑定">
          <a href="#内存模型：-动态绑定" class="heading-link"><i class="fas fa-link"></i></a>内存模型： 动态绑定</h3>
      <hr>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr.jpg" alt="内存模型"></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line">C *p = <span class="keyword">new</span> C;</span><br><span class="line">(*p).vfunc2();</span><br><span class="line"><span class="comment">// 相当于,其中 n 表示虚表中的第 n 个虚函数</span></span><br><span class="line">(*(p-&gt;vptr)[n])(p);</span><br><span class="line">(* p-&gt;vptr[n] )(p);</span><br></pre></td></tr></table></div></figure>
<hr>

        <h3 id="应用：PPT-图形类-多态的应用">
          <a href="#应用：PPT-图形类-多态的应用" class="heading-link"><i class="fas fa-link"></i></a>应用：PPT 图形类(多态的应用)</h3>
      <p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr2.jpg" alt="PPT类"></p>

        <h3 id="总结：">
          <a href="#总结：" class="heading-link"><i class="fas fa-link"></i></a>总结：</h3>
      <p>&emsp;C++ 编译器看到一个函数调用，会有两个考量（静态绑定，动态绑定)</p>
<ol>
<li>静态绑定是被编译成: CALL xxxx(func address)。</li>
<li>但如果符合某些条件就会动态绑定：<ul>
<li>通过指针调用</li>
<li>指针向上转型 up-cast</li>
<li>所调用的是虚函数(virtual func)<br>动态绑定的形式：虚机制<br>多态：指针具有很多的类型（型态）</li>
</ul>
</li>
</ol>
<hr>

        <h2 id="关于-this-pointer">
          <a href="#关于-this-pointer" class="heading-link"><i class="fas fa-link"></i></a>关于 this pointer</h2>
      <blockquote>
<blockquote>
<p>设计分析继承体系时要对this pointer有一个清晰的认识<br>对象调用成员函数时，该对象的this指正就会隐含地传入函数中<br>下图中在对象调用OnFileOpen()时传入对象地址this，因此碰到虚函数Serialize()函数后，回去寻找CMyDoc类的虚函数表中的函数（动态绑定）</p>
</blockquote>
</blockquote>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/templateMethod.jpg" alt=""></p>
<hr>

        <h2 id="谈谈-const-const-member-function-常量成员函数">
          <a href="#谈谈-const-const-member-function-常量成员函数" class="heading-link"><i class="fas fa-link"></i></a>谈谈 const (const member function 常量成员函数)</h2>
      <blockquote>
<p>const 是属于函数签名的一部分</p>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Class() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> mem;&#125; <span class="comment">// 保证不更改 mem</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> mem;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>const object(datamember不可变动)</th>
<th>non-const object(datamem可变动)</th>
</tr>
</thead>
<tbody>
<tr>
<td>const member functions(保证datamenber不变)</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>non-const member functions(不保证datamember不变)</td>
<td>无法调用</td>
<td>YES </td>
</tr>
</tbody>
</table></div>
<blockquote>
<p>当成员函数的 const 和 non-const 版本同时存在时，const Object 只会调用 const 版本，non-const Object 只会调用 non-const 版本</p>
</blockquote>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/db.jpg" alt=""></p>
<hr>

        <h2 id="关于-new-delete-array-new-array-delete-重载">
          <a href="#关于-new-delete-array-new-array-delete-重载" class="heading-link"><i class="fas fa-link"></i></a>关于 new , delete. array new , array delete.(重载)</h2>
      
        <h3 id="Part-I-承接：">
          <a href="#Part-I-承接：" class="heading-link"><i class="fas fa-link"></i></a>Part I 承接：</h3>
      <p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/new.png" alt=""></p>
<hr>

        <h3 id="全局重载形式">
          <a href="#全局重载形式" class="heading-link"><i class="fas fa-link"></i></a>全局重载形式</h3>
      <p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/overideDelete.jpg" alt=""></p>

        <h3 id="成员重载形式">
          <a href="#成员重载形式" class="heading-link"><i class="fas fa-link"></i></a>成员重载形式</h3>
      <blockquote>
<p>new 分解为 3 个动作<br>delete 分解为 2 个动作<br>接管内存的分配和释放的行为</p>
</blockquote>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride.jpg" alt=""></p>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride%5B%5D.jpg" alt=""></p>
<hr>

        <h3 id="示例，-接口">
          <a href="#示例，-接口" class="heading-link"><i class="fas fa-link"></i></a>示例， 接口</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FOO__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FOO__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> _id;</span><br><span class="line">		<span class="keyword">long</span> _data;</span><br><span class="line">		<span class="built_in">string</span> _str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Foo() : _id(<span class="number">0</span>) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default ctor. this = "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">		Foo(<span class="keyword">int</span> id) : _id(id) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"ctor. this = "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//virtual    // 可选的 virtual 关键字</span></span><br><span class="line">	~Foo() &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"dtor. this = "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* phead, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* phead, <span class="keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* Foo::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Foo* p = (Foo*) <span class="built_in">malloc</span>(size);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo:new has been called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* Foo::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* phead,<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo:delete has been called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	Foo* p = (Foo*) <span class="built_in">malloc</span>(size);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo:new[] has been called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* phead, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo:delete[] has been called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// END DEFINE</span></span></span><br></pre></td></tr></table></div></figure>

        <h4 id="测试：">
          <a href="#测试：" class="heading-link"><i class="fas fa-link"></i></a>测试：</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Foo) = "</span> &lt;&lt; <span class="keyword">sizeof</span>(Foo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Foo *p = <span class="keyword">new</span> Foo(<span class="number">7</span>);</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"============================================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Foo* pArray = <span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] pArray;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"********************************************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制全局,不会进入重载函数</span></span><br><span class="line">	Foo* _p = ::<span class="keyword">new</span> Foo(<span class="number">7</span>);</span><br><span class="line">	::<span class="keyword">delete</span>[] _p;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"============================================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制全局</span></span><br><span class="line">	Foo *_pArray = <span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line">	::<span class="keyword">delete</span>[] _pArray;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foo.png" alt="Foo with non-virtual dtor"></p>
<p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foowithvirtual.png" alt="Foo with virtual dtor"></p>
<hr>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://www.ccyh.xyz">Liam</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://www.ccyh.xyz/p/6c8e.html">https://www.ccyh.xyz/p/6c8e.html</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://www.ccyh.xyz/tags/C/">C++</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/p/f367.html"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">快速排序及其改进</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/p/fb7f.html"><span class="paginator-prev__text">LeetCode23 合并 K 个排序链表(Hard)</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-程序设计II-兼谈对象模型"><span class="toc-number">1.</span> <span class="toc-text">
          C++ 程序设计II 兼谈对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Conversion-function-转换函数-operator-type"><span class="toc-number">1.1.</span> <span class="toc-text">
          Conversion function - 转换函数 operator type()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#non-explicit-one-argument-ctor"><span class="toc-number">1.2.</span> <span class="toc-text">
          non-explicit-one-argument ctor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit-one-argument-ctor"><span class="toc-number">1.3.</span> <span class="toc-text">
          explicit-one-argument ctor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pointer-like-classes-关于智能指针"><span class="toc-number">1.4.</span> <span class="toc-text">
          pointer-like classes, 关于智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pointer-like-classes-关于迭代器-一种特别的智能指针"><span class="toc-number">1.5.</span> <span class="toc-text">
          pointer-like classes, 关于迭代器(一种特别的智能指针)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function-like-classes-所谓-仿函数-像函数的类"><span class="toc-number">1.6.</span> <span class="toc-text">
          function-like classes, 所谓 仿函数 (像函数的类)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespase-经验谈"><span class="toc-number">1.7.</span> <span class="toc-text">
          namespase 经验谈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class-template-模板类-泛型编程"><span class="toc-number">1.8.</span> <span class="toc-text">
          class template, 模板类(泛型编程)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function-template-函数模板"><span class="toc-number">1.9.</span> <span class="toc-text">
          function template, 函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#member-template-成员模板-令构造函数更有弹性"><span class="toc-number">1.10.</span> <span class="toc-text">
          member template, 成员模板(令构造函数更有弹性)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-number">1.10.0.1.</span> <span class="toc-text">
          例子:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#specialization-模板特化"><span class="toc-number">1.11.</span> <span class="toc-text">
          specialization, 模板特化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partial-specialization-模板偏特化-–-个数上的偏"><span class="toc-number">1.12.</span> <span class="toc-text">
          partial specialization, 模板偏特化 – 个数上的偏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template-template-parameter-模板模板参数"><span class="toc-number">1.13.</span> <span class="toc-text">
          template template parameter, 模板模板参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#这个不是-template-template-parameter"><span class="toc-number">1.13.1.</span> <span class="toc-text">
          这个不是 template template parameter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-C-标准库"><span class="toc-number">1.14.</span> <span class="toc-text">
          关于 C++ 标准库</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11-新特性"><span class="toc-number">2.</span> <span class="toc-text">
          C++11 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#variadic-templates-数量不定的模板参数-since-C-11"><span class="toc-number">2.1.</span> <span class="toc-text">
          variadic templates  数量不定的模板参数 (since C++11)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-语法糖-since-c-11"><span class="toc-number">2.2.</span> <span class="toc-text">
          auto 语法糖(since c++11)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range-base-for-语法糖-since-C-11"><span class="toc-number">2.3.</span> <span class="toc-text">
          range-base for 语法糖(since C++11)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference-引用-代表-实际上是指针实现的"><span class="toc-number">2.4.</span> <span class="toc-text">
          reference 引用(代表),实际上是指针实现的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object-Model-对象模型"><span class="toc-number">3.</span> <span class="toc-text">
          Object Model 对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-I-的承接"><span class="toc-number">3.1.</span> <span class="toc-text">
          Part I 的承接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-vptr-和-vtbl-虚指针和虚表"><span class="toc-number">3.2.</span> <span class="toc-text">
          关于 vptr 和 vtbl (虚指针和虚表)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存模型：-动态绑定"><span class="toc-number">3.2.1.</span> <span class="toc-text">
          内存模型： 动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用：PPT-图形类-多态的应用"><span class="toc-number">3.2.2.</span> <span class="toc-text">
          应用：PPT 图形类(多态的应用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结："><span class="toc-number">3.2.3.</span> <span class="toc-text">
          总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-this-pointer"><span class="toc-number">3.3.</span> <span class="toc-text">
          关于 this pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谈谈-const-const-member-function-常量成员函数"><span class="toc-number">3.4.</span> <span class="toc-text">
          谈谈 const (const member function 常量成员函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-new-delete-array-new-array-delete-重载"><span class="toc-number">3.5.</span> <span class="toc-text">
          关于 new , delete. array new , array delete.(重载)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-I-承接："><span class="toc-number">3.5.1.</span> <span class="toc-text">
          Part I 承接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局重载形式"><span class="toc-number">3.5.2.</span> <span class="toc-text">
          全局重载形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员重载形式"><span class="toc-number">3.5.3.</span> <span class="toc-text">
          成员重载形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例，-接口"><span class="toc-number">3.5.4.</span> <span class="toc-text">
          示例， 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#测试："><span class="toc-number">3.5.4.1.</span> <span class="toc-text">
          测试：</span></a></li></ol></li></ol></li></ol></li></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">21</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Liam</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v3.8.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zindex="-1"></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>