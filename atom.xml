<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liam&#39;s Blog</title>
  
  <subtitle>Liam&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ccyh.xyz/"/>
  <updated>2020-05-06T09:06:17.427Z</updated>
  <id>https://www.ccyh.xyz/</id>
  
  <author>
    <name>Liam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你好呀</title>
    <link href="https://www.ccyh.xyz/p/cd37.html"/>
    <id>https://www.ccyh.xyz/p/cd37.html</id>
    <published>2020-04-09T20:55:22.000Z</published>
    <updated>2020-05-06T09:06:17.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这个站点已经不跟新啦，需要交换友链啥的请移步新站点"><a href="#这个站点已经不跟新啦，需要交换友链啥的请移步新站点" class="headerlink" title="这个站点已经不跟新啦，需要交换友链啥的请移步新站点"></a>这个站点已经不跟新啦，需要交换友链啥的请移步新站点</h1><p><a href="https://www.ccyh.xyz">新站点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这个站点已经不跟新啦，需要交换友链啥的请移步新站点&quot;&gt;&lt;a href=&quot;#这个站点已经不跟新啦，需要交换友链啥的请移步新站点&quot; class=&quot;headerlink&quot; title=&quot;这个站点已经不跟新啦，需要交换友链啥的请移步新站点&quot;&gt;&lt;/a&gt;这个站点已经不跟新啦，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不确定性推理</title>
    <link href="https://www.ccyh.xyz/p/b411.html"/>
    <id>https://www.ccyh.xyz/p/b411.html</id>
    <published>2020-03-30T16:11:26.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上帝也掷骰子"><a href="#上帝也掷骰子" class="headerlink" title="上帝也掷骰子"></a>上帝也掷骰子</h2><hr><p>大千世界，并非一切事物都可以进行精确的计算，都可以用是非来衡量那么简单。19实际爱因斯坦与波尔的辩论的结局就是：上帝他老人家也是个赌徒，我们所处的客观世界充满着不确定。因此，发展一套研究不确定性的理论迫在眉睫。好在我们已经有了。</p><a id="more"></a><h2 id="不确定性"><a href="#不确定性" class="headerlink" title="不确定性"></a>不确定性</h2><hr><p>在不确定推理中，规则的前件（证据），后件（结论）以及规则本身在某种程度上都是不确定的。</p><ul><li><strong>证据不确定</strong>：作为推理依据，由人们从自然界中获取或总结归纳出来的的信息有太多的不确定性因素。</li><li><strong>规则不确定</strong>：作为系统中的启发式知识，一般有专家给出，大多依靠经验。</li><li><strong>推理的不确定性</strong>：由不确定的证据和规则推导出的结论显然也带有某种不确定性。</li></ul><h2 id="不确定性推理的基本问题"><a href="#不确定性推理的基本问题" class="headerlink" title="不确定性推理的基本问题"></a>不确定性推理的基本问题</h2><hr><p>由于证据和规则的不确定性会导致结论的不确定性，而要想得到结论的不确定性程度就必须将证据和规则的不确定性在推理过程中正确地传递给结论。因此要将其化为可计算的数值问题，必须实现不确定性的表示与度量、匹配、传递、合成等问题。</p><ol><li><p>不确定性的表示问题：</p><ul><li>数值表示：$P(A) = 0.9$</li><li>语义表示：发生 A 有很大的可能性<br>显然，数值表示更适合进行数学计算</li></ul></li><li><p>计算问题：<br>计算问题主要是指不确定性的传递和更新的过程</p><ul><li>单个规则：已知 $P(A)$ 的确定性度量且 $A\rightarrow B$, 求 $P(B)$</li><li>规则合成：从两个规则分别得到$A$的两个可信度度量$P_1(A)$和$P_2(A)$，求两个规则合成后的最终可信度度量$P(A)$</li><li><p>证据组合：已知两个证据的可信度度量$P(A_1),P(A_2)$,求两个证据不同组合下的可信度度量 $P(A_1 \wedge A_2), P(A_1\vee A_2)$<br>另外，初始敏体的不确定性一般有专家经验得出。大体推理过程如下：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/20200330051257539.png" alt=""><br></center><p>其中：<br>$R_1: A_1 \wedge A_2 \rightarrow B_1$<br>$R_2: A_2 \vee A_3 \rightarrow B_2$<br>$R_3: B_1 \rightarrow B$<br>$R_4: B_2 \rightarrow B$</p></li></ul></li><li><p>语义问题：<br>将计算过程符号化，一般用概率论的符号语言。</p></li></ol><h2 id="不确定性推理的方法"><a href="#不确定性推理的方法" class="headerlink" title="不确定性推理的方法"></a>不确定性推理的方法</h2><hr><p>不确定性推理的方法有许多，在此主要介绍四种：</p><ul><li>贝叶斯网络方法</li><li>主观贝叶斯方法</li><li>确定性方法</li><li>证据理论</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;上帝也掷骰子&quot;&gt;&lt;a href=&quot;#上帝也掷骰子&quot; class=&quot;headerlink&quot; title=&quot;上帝也掷骰子&quot;&gt;&lt;/a&gt;上帝也掷骰子&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;大千世界，并非一切事物都可以进行精确的计算，都可以用是非来衡量那么简单。19实际爱因斯坦与波尔的辩论的结局就是：上帝他老人家也是个赌徒，我们所处的客观世界充满着不确定。因此，发展一套研究不确定性的理论迫在眉睫。好在我们已经有了。&lt;/p&gt;
    
    </summary>
    
      <category term="人工智能" scheme="https://www.ccyh.xyz/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="AI" scheme="https://www.ccyh.xyz/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>利用归结原理求解问题</title>
    <link href="https://www.ccyh.xyz/p/a36d.html"/>
    <id>https://www.ccyh.xyz/p/a36d.html</id>
    <published>2020-03-08T11:18:11.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求解问题的步骤"><a href="#求解问题的步骤" class="headerlink" title="求解问题的步骤"></a>求解问题的步骤</h2><p>(1) 已知前提$F$用谓词公式表示并化为子句集$S$<br>(2) 把待求解的问题$Q$用谓词公式表示，并否定$Q$,在与$ANSWER$构成析取式$(\neg Q \vee ANSWER)$;<br>(3) 把$(\neg Q \vee ANSWER)$化为子句，并入到子句集$S$中，得到子句集$S’$;<br>(4) 对子句集$S’$应用归结原理进行归结；<br>(5) 若得到归结式 $ANSWER$, 则答案就在$ANSWER$中。</p><a id="more"></a><hr><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>(1) 已知：<br>$F_1$: 王先生（Wang）是小李（Li）的老师<br>$F_2$: 小李与小张（Zhang）是同班同学<br>$F_3$: 如果 x 与 y 是同班同学，则 x 的老师也是 y 的老师。<br>求：小张的老师是谁？</p><p>解：定义谓词<br>$T(x,y)$: x 是 y 的老师<br>$C(x,y)$: x 和 y 是同学<br>把已知前提表达成谓词公式：<br>$F_1:T(Wang,Li)$<br>$F_2:C(Li,Zhang)$<br>$F_3:\forall x\forall y\forall z(C(x,y)\wedge T(z,x)\rightarrow T(z,y))$<br>设$x$为小张的老师，把目标表示成谓词公式，并把它否定后与$ANSWER$析取：<br>$$<br>\color{red}{\neg} \exists xT(x,Zhang) \vee ANSWER(x)<br>$$<br>把上述公式化为子句集：<br>$C_1:T(Wang,Li)$<br>$C_2:C(Li,Zhang)$<br>$C_3:\neg C(x,y)\vee \neg T(z,x)\vee T(z,y)$<br>$C_4:\neg T(u,Zhang)\vee ANSWER(u)$</p><p>应用归结原理进行归结：<br>$C_{13}: \neg C(Li,y)\vee T(Wang,y)$<br>$C_{134}: \neg C(Li,Zhang)\vee ANSWER(Wang)$<br>$C_{1234}: ANSWER(Wang)$<br>故小张的老师是王老师。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%88%A9%E7%94%A8%E5%BD%92%E7%BB%93%E5%8E%9F%E7%90%86%E6%B1%82%E8%A7%A3%E9%97%AE%E9%A2%98/20200308032354633.png" alt=""><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;求解问题的步骤&quot;&gt;&lt;a href=&quot;#求解问题的步骤&quot; class=&quot;headerlink&quot; title=&quot;求解问题的步骤&quot;&gt;&lt;/a&gt;求解问题的步骤&lt;/h2&gt;&lt;p&gt;(1) 已知前提$F$用谓词公式表示并化为子句集$S$&lt;br&gt;(2) 把待求解的问题$Q$用谓词公式表示，并否定$Q$,在与$ANSWER$构成析取式$(\neg Q \vee ANSWER)$;&lt;br&gt;(3) 把$(\neg Q \vee ANSWER)$化为子句，并入到子句集$S$中，得到子句集$S’$;&lt;br&gt;(4) 对子句集$S’$应用归结原理进行归结；&lt;br&gt;(5) 若得到归结式 $ANSWER$, 则答案就在$ANSWER$中。&lt;/p&gt;
    
    </summary>
    
      <category term="人工智能" scheme="https://www.ccyh.xyz/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="AI" scheme="https://www.ccyh.xyz/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>归结反演</title>
    <link href="https://www.ccyh.xyz/p/fba.html"/>
    <id>https://www.ccyh.xyz/p/fba.html</id>
    <published>2020-03-07T20:11:26.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用归结原理证明定理"><a href="#应用归结原理证明定理" class="headerlink" title="应用归结原理证明定理"></a>应用归结原理证明定理</h2><p><strong>步骤：</strong></p><ol><li>将一直前提表示为谓词公式 $F$。</li><li>将待证明的结论表示为谓词公式 $Q$， 并否定得到 $\neg Q$。</li><li>把谓词公式集 {$F,\neg Q$} 化为子句集 $S$。</li><li>应用归结原理对子句集 $S$ 中的子句进行归结，并把每次归结得到的归结式都并入到 $S$ 中。如此反复进行，若出现了空子句，则停止归结，此时就证明了结论 $Q$ 为真。</li></ol><a id="more"></a><p><strong>例1：</strong> 某公司招聘工作人员，$A,B,C$ 三人应试，经面试后公司表示如下想法：</p><ul><li>三人中至少录取一人。</li><li>如果录取$A$而不录取$B$,则一定录取$C$。</li><li>如果录取$B$,则一定录取$C$.</li></ul><p>求证：公司一定录取 $C$。</p><p>$Proof:$<br>(1) 将公司想法用谓词公式表示：$P(x):$ 录取 $x$<br>前提：</p><ul><li>$P(A) \vee P(B)\vee P(C)$</li><li>$P(A) \wedge \neg P(B) \rightarrow P(C)$</li><li>$P(B) \rightarrow P(C)$</li></ul><p>待证结论：$P(C)$</p><p>(2) 将待证结论否定得：$\neg P(C)$<br>(3) 将谓词公式集 {$P(A) \vee P(B)\vee P(C),P(A) \wedge \neg P(B) \rightarrow P(C),P(B) \rightarrow P(C)$}化成子句集：<br>$S=${$P(A) \vee P(B)\vee P(C),\neg P(A) \vee P(B) \vee P(C),\neg P(B) \vee P(C),\neg P(C)$}<br>(4) 应用归结原理进行归结<br>$C_1=P(A) \vee P(B)\vee P(C)$,<br>$C_2=\neg P(A) \vee P(B) \vee P(C)$,<br>$C_3=\neg P(B) \vee P(C)$,<br>$C_4=\neg P(C)$<br>归结：<br>$C_1 \otimes C_2 = C_{12}=P(B)\vee P(C)$<br>$C_3 \otimes C_{12} = C_{123} = P(C)$<br>$C_4 \otimes C_{123} = C_{1234} = NIL$ 空子句<br>结论得证。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E7%BB%93%E5%8F%8D%E6%BC%94/20200307084330368.png" alt=""><br></center><p><strong>例2：</strong> 已知：<br>规则1：任何人的兄弟不是女性<br>规则2：任何人的姐妹必是女性<br>事实：Mary 是 Bill 的姐妹<br>求证：Mary 不是 Tom 的兄弟</p><p>(1) 谓词表示：<br>$brother(x,y):$ $x$ 是 $y$ 的兄弟<br>$sister(x,y):$ $x$ 是 $y$ 的姐妹<br>$woman(x):$ $x$ 是女性</p><p>规则1：$\forall x \forall y(brother(x,y)\rightarrow \neg woman(x))$<br>规则2：$\forall x\forall y(sister(x,y)\rightarrow woman(x))$<br>事实：$sister(Mary,Bill)$<br>待证结论：$\neg brother(Mary,Tom)$</p><p>(2) 将待证结论否定得：$brother(Mary,Tom)$<br>(3) 谓词公式集 {$\forall x \forall y(brother(x,y)\rightarrow \neg woman(x))$,$\forall x\forall y(sister(x,y)\rightarrow woman(x))$,$sister(Mary,Bill)$,$\neg brother(Mary,Tom)$}化成子句集：<br>$S= ${<br>$C_1=\neg brother(x,y)\vee \neg woman(x)$,<br>$C_2=\neg sister(x,y)\vee woman(x)$,<br>$C_3=sister(Mary,Bill)$,<br>$C_4=brother(Mary,Tom)$<br>}</p><p>(4) 应用归结原理进行归结：<br>$C_{23}=woman(Mary)$<br>$C_{123}=\neg brother(Mary,y)$<br>$C_{1234}=NIL$ 空子句<br>结论得证。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用归结原理证明定理&quot;&gt;&lt;a href=&quot;#应用归结原理证明定理&quot; class=&quot;headerlink&quot; title=&quot;应用归结原理证明定理&quot;&gt;&lt;/a&gt;应用归结原理证明定理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将一直前提表示为谓词公式 $F$。&lt;/li&gt;
&lt;li&gt;将待证明的结论表示为谓词公式 $Q$， 并否定得到 $\neg Q$。&lt;/li&gt;
&lt;li&gt;把谓词公式集 {$F,\neg Q$} 化为子句集 $S$。&lt;/li&gt;
&lt;li&gt;应用归结原理对子句集 $S$ 中的子句进行归结，并把每次归结得到的归结式都并入到 $S$ 中。如此反复进行，若出现了空子句，则停止归结，此时就证明了结论 $Q$ 为真。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="人工智能" scheme="https://www.ccyh.xyz/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="AI" scheme="https://www.ccyh.xyz/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>谓词逻辑归结原理</title>
    <link href="https://www.ccyh.xyz/p/3027.html"/>
    <id>https://www.ccyh.xyz/p/3027.html</id>
    <published>2020-03-07T11:37:40.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归结法基本原理"><a href="#归结法基本原理" class="headerlink" title="归结法基本原理"></a>归结法基本原理</h2><p>归结法的基本原理是采用反证法（也称反演推理法）将待证明的表达式（定理）转换成为逻辑公式（谓词公式），然后再进行归结，归结能够顺利完成，证明原公式（定理）是正确的。</p><blockquote><p>$def:$ $Q$ 为 $P_1,P_2, \cdots ,P_n$ 的逻辑结论，当且仅当 $P\wedge \neg Q$ 是不可满足的，结论才成立</p></blockquote><a id="more"></a><p>这样做的原因是证明不可满足性要比证明可满足性简单得多。通俗来讲，若要证明定理：张三是个好人。可以反向证明定理：张三不是个好人那是不可能的。</p><p>用符号公式表示就是:</p><blockquote><p>待证定理：$P \Rightarrow Q$<br>置换转换为普通谓词公式:<br>$$<br>P \rightarrow Q \Leftrightarrow \neg P\vee Q<br>$$<br>再将其否定：$\neg(\neg P\vee Q) \Leftrightarrow P\wedge \neg Q$<br>即证明 $P\wedge \neg Q$ 为永假式</p></blockquote><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91%E5%BD%92%E7%BB%93%E5%8E%9F%E7%90%86/20200307122016949.png" alt="归结演绎推理的思路"><br></center><h2 id="子句集"><a href="#子句集" class="headerlink" title="子句集"></a>子句集</h2><p>为了描述子句集，先给出如下几个名词的定义：</p><ul><li>原子谓词公式：一个不能再分解的命题</li><li>文字：原子谓词公司及其否定</li><li><ul><li>$P$: 正文字</li></ul></li><li><ul><li>$\neg P$: 负文字</li></ul></li><li>子句：任何文字的<strong>析取式</strong>，任何文字本身也都是句子。</li><li>空子句：不包含任何文字的子句</li><li>子句集：所有子句的集合</li></ul><p><strong>例1：</strong> 将下列谓词公式化为子句集<br>$$<br>\forall x (\forall yP(x,y) \rightarrow \neg \forall y(Q(x,y)\rightarrow R(x,y)))<br>$$<br>A. 利用一下公式消去谓词公式中的$\rightarrow$ 和 $\leftrightarrow$ 符号</p><blockquote><p>$P\rightarrow Q\Leftrightarrow \neg P\vee Q,P\leftrightarrow Q\Leftrightarrow (P\wedge Q)\vee (\neg P\wedge \neg Q)$</p></blockquote><p>$\color{red}{\Longleftrightarrow} \forall x (\neg \forall yP(x,y) \vee \neg \forall y(\neg Q(x,y)\vee R(x,y)))$<br>B. 利用下列公式把否定符号 $\neg$ 移到紧靠谓词的位置上</p><blockquote><p>双重否定律：$\neg (\neg P)\Leftrightarrow P$<br>摩根律：$\neg (p\wedge q)\Leftrightarrow \neg p\vee \neg q$<br>量词否定转换率：$\neg \exists xP\Leftrightarrow \forall x\neg P,\neg \forall xP\Leftrightarrow \exists x \neg P$</p></blockquote><p>$\color{red}{\Longleftrightarrow} \forall x(\exists y\neg P(x,y)\vee \exists y(Q(x,y)\wedge \neg R(x,y)))$<br>C. 变量标准化(变元易名)</p><blockquote><p>$\exists xP(x) = \exists yP(y),\forall xP(x) = \forall yP(y)$</p></blockquote><p>$\color{red}{\Longleftrightarrow} \forall x(\exists y\neg P(x,y)\vee \exists \color{green}{z}(Q(x,\color{green}{z})\wedge \neg R(x,\color{green}{z})))$</p><p>D. 消去存在量词（两种情况）</p><blockquote><p>$a.$ 存在量词不出现在全称量词的辖域内<br>$b.$ 存在量词出现在一个或者多个全称量词的辖域内<br>对于一般情况：<br>$\forall x_1(\forall x_2(\cdots \forall x_n(\exists yP(x_1,x_2,\cdots ,x_n,y)))\cdots)$<br>存在量词 $y$ 的Skolem函数为 $y=f(x_1,x_2,\cdots ,x_n)$<br>Skolem化：用Slolem函数代替每个存在量词化的变量的过程</p></blockquote><p>如本例中两个存在量词 $y,z$ 只收到全称量词 $x$ 的约束，因此可以令：$y = f(x),z = g(x)$<br>$\color{red}{\Longleftrightarrow} \forall x(\neg P(x,\color{green}{f(x)})\vee (Q(x,\color{green}{g(x)})\wedge \neg R(x,\color{green}{g(x)})))$</p><p>E. 化为前束范式（本例中到此式子已经满足前束范式标准了）</p><p>$\color{red}{\Longleftrightarrow} \forall x(\neg P(x,\color{green}{f(x)})\vee (Q(x,\color{green}{g(x)})\wedge \neg R(x,\color{green}{g(x)})))$</p><p>F. 化为 $Skolem$ 标准型</p><blockquote><p>$Skolem$ 标准型：<br>$M:$ 子句的合取式，称为Skolem标准型的母式，即去掉所有量词的前束范式。<br>利用分配律：<br>$p\vee(q\wedge r)\Leftrightarrow (p\vee q)\wedge (p\vee r)$<br>$p\wedge(q\vee r)\Leftrightarrow (p\wedge q)\vee (p\wedge r)$</p></blockquote><p>$\color{red}{\Longleftrightarrow} \forall x((\neg P(x,\color{green}{f(x)})\vee Q(x,\color{green}{g(x)}))\wedge (\neg P(x,\color{green}{f(x)})\vee \neg R(x,\color{green}{g(x)})))$</p><p>G. 略去全称量词<br>$\color{red}{\Longleftrightarrow} ((\neg P(x,\color{green}{f(x)})\vee Q(x,\color{green}{g(x)}))\wedge (\neg P(x,\color{green}{f(x)})\vee \neg R(x,\color{green}{g(x)})))$</p><p>H. 消去合取词,成为一个子句集合（析取句的集合）<br>$\color{red}{\Longleftrightarrow} {(\neg P(x,\color{green}{f(x)})\vee Q(x,\color{green}{g(x)}), \neg P(x,\color{green}{f(x)})\vee \neg R(x,\color{green}{g(x)})}$</p><p>I. 子句变量的标准化（不同子句用不同变元）<br>$\color{red}{\Longleftrightarrow} {(\neg P(x,\color{green}{f(x)})\vee Q(x,\color{green}{g(x)}), \neg P(y,\color{green}{f(y)})\vee \neg R(y,\color{green}{g(y)})}$</p><hr><h2 id="鲁滨逊归结原理-判别子句集的不可满足性"><a href="#鲁滨逊归结原理-判别子句集的不可满足性" class="headerlink" title="鲁滨逊归结原理(判别子句集的不可满足性)"></a>鲁滨逊归结原理(判别子句集的不可满足性)</h2><blockquote><p>出发点：由于子句集当中的子句之间的关系是合取关系，因此只要有一个子句不可满足，则整个子句集就不可满足。</p></blockquote><p><strong>⭐️鲁滨逊归结原理的基本思想：</strong></p><ul><li>检查子句集 $S$ 中是否包含 <strong>空子句</strong> ，若包含，则不可满足。</li><li>若不包含空子句，在 $S$ 中选择合适的子句进行归结，一旦归结出空子句，就说明 $S$ 是不可满足的。</li><li>另外需注意的是，对于鲁滨逊归结原理，如果在归结过程中出现空子句则可说明子句集的不可满足性；但若无法归结出空子句也无法说明该子句集可满足，也就是说鲁滨逊归结原理只能用来证伪。</li></ul><p><strong>命题逻辑中的归结原理：</strong><br>$Def:$ 归结指的是，设$C_1$与$C_2$是子句集中的任意两个句子，如果$C_1$中的文字$L_1$与$C_2$中的文字$L_2$互补(同一谓词的正负文字)，那么从$C_1$与$C_2$中分别消去$L_1$和$L_2$, 并将两个子句中余下的部分 <strong>析取</strong>，构成一个新的子句 $C_{12}$。<br>$Def:$ 归结式$C_{12}$是其亲本子句$C_1$和$C_2$的逻辑结论。即如果$C_1$与$C_2$为真，则$C_{12}$为真。<br><strong>推论1：</strong> 由$C_{12}$代替$C_1$和$C_2$后的新的子句集$S_1$的不可满足性也可代表原子句集的不可满足性（单向的）。<br><strong>推论2：</strong> 若不作代替，直接将$C_{12}$加入原子句集$S$得到新的子句集$S_2$,则$S$与$S_2$在不可满足的意义上是等价的（双向的）。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91%E5%BD%92%E7%BB%93%E5%8E%9F%E7%90%86/20200307040000676.png" alt="子句归结"><br></center><h3 id="⭐️谓词逻辑中的归结原理：（含有变量的子句的归结）"><a href="#⭐️谓词逻辑中的归结原理：（含有变量的子句的归结）" class="headerlink" title="⭐️谓词逻辑中的归结原理：（含有变量的子句的归结）"></a>⭐️谓词逻辑中的归结原理：（含有变量的子句的归结）</h3><p>&emsp;谓词逻辑的归结比命题逻辑的归结要复杂得多，其中一个原因就是谓词逻辑公式中含有个体变量与函数。因此寻找互补的子句的过程就比较复杂。例如：<br>$$<br>P(x)\vee Q(y)\qquad and \qquad \neg P(a)\vee R(z)<br>$$<br>就不易从直接比较中发现这两个子句中含有的互补对，但如果将$x$取值为$a$,这很显然这两个句子中有互补对。</p><h4 id="置换与合一：（对个体变量做适当替换）"><a href="#置换与合一：（对个体变量做适当替换）" class="headerlink" title="置换与合一：（对个体变量做适当替换）"></a>置换与合一：（对个体变量做适当替换）</h4><p><strong>置换：</strong> 将子句中的变量做适当替换，可替换成常量、变量、Skolem函数。<br><strong>合一：</strong> 寻找相对变量的置换，使两个谓词公式一致</p><p><strong>如：</strong> $C_1=P(x)\vee Q(a), C_2=\neg P(b)\vee R(x)$<br>解：<br>$\sigma ={ f(a)/x }$; $x$ 用$f(a)$替换<br>$C_1\sigma = P(f(a))\vee Q(f(a))$,<br>选互补对：$L_1=P(f(a)),L_2=\neg P(y), \sigma = { f(a)/y }$<br>得归结式：$C_{12}=R(b)\vee Q(f(a))$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;归结法基本原理&quot;&gt;&lt;a href=&quot;#归结法基本原理&quot; class=&quot;headerlink&quot; title=&quot;归结法基本原理&quot;&gt;&lt;/a&gt;归结法基本原理&lt;/h2&gt;&lt;p&gt;归结法的基本原理是采用反证法（也称反演推理法）将待证明的表达式（定理）转换成为逻辑公式（谓词公式），然后再进行归结，归结能够顺利完成，证明原公式（定理）是正确的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$def:$ $Q$ 为 $P_1,P_2, \cdots ,P_n$ 的逻辑结论，当且仅当 $P\wedge \neg Q$ 是不可满足的，结论才成立&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="人工智能" scheme="https://www.ccyh.xyz/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="AI" scheme="https://www.ccyh.xyz/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>谓词演算的推理理论</title>
    <link href="https://www.ccyh.xyz/p/ccf3.html"/>
    <id>https://www.ccyh.xyz/p/ccf3.html</id>
    <published>2020-03-06T20:23:03.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>$UI$(全称量词消去规则)：$\forall xA(x)\Rightarrow A(x)$</li><li>$EI$(存在量词消去规则)：$\exists xA(x)\Rightarrow A(c)$</li><li>$UG$(全称量词引入规则)：$A(y)\Rightarrow \forall x A(x)$, $y$ 为任意值， $A(y)$ 为真</li><li>$EG$(存在量词引入规则)：$A(c)\Rightarrow \exists xA(x)$</li></ol></blockquote><a id="more"></a><p><strong>例1：</strong> 构造下列推理的证明</p><p><1> 前提：$\forall x(F(x)\rightarrow G(x)),\forall xF(x)$<br>结论：$\forall xG(x)$</1></p><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$\forall x(F(x)\rightarrow G(x))$</td><td>前提引入</td></tr><tr><td>2</td><td>$F(c)\rightarrow G(c)$</td><td>1，$UI$</td></tr><tr><td>3</td><td>$\forall xF(x)$</td><td>前提引入</td></tr><tr><td>4</td><td>$F(c)$</td><td>3，$UI$</td></tr><tr><td>5</td><td>$G(c)$</td><td>2，4，假言推理</td></tr><tr><td>6</td><td>$\forall xG(x)$</td><td>5，$UG$</td></tr></tbody></table><p><2> 用归谬法(反证法)证明下列推理<br>前提：$\forall x(F(x)\vee G(x)),\neg \exists xG(x)$<br>结论：$\exists xF(x)$</2></p><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$\neg \exists xF(x)$</td><td>附加前提引入，假设结论不成立</td></tr><tr><td>2</td><td>$\forall x\neg F(x)$</td><td>1，量词否定转换</td></tr><tr><td>3</td><td>$\neg F(c)$</td><td>2，$UI$</td></tr><tr><td>4</td><td>$\neg \exists xG(x)$</td><td>前提引入</td></tr><tr><td>5</td><td>$\forall x\neg G(x)$</td><td>4，量词否定转换</td></tr><tr><td>6</td><td>$\neg G(c)$</td><td>5，$UI$</td></tr><tr><td>7</td><td>$\forall x(F(x)\vee G(x))$</td><td>前提引入</td></tr><tr><td>8</td><td>$F(c)\vee G(c)$</td><td>7，$UI$</td></tr><tr><td>9</td><td>$F(c)$</td><td>6，8，析取三段论</td></tr><tr><td>10</td><td>$\neg F(c)\wedge F(c)$</td><td>3，9 ，合取(出现矛盾，假设不成立❌)</td></tr></tbody></table><hr><p><strong>例2：</strong> ⭐️证明下述论断的正确性</p><ul><li>所有哺乳动物都是脊椎动物</li><li>并非所有哺乳动物都是胎生动物</li><li>故有些脊椎动物不是胎生动物</li></ul><p>$proof:$<br>命题符号化：</p><ul><li>$p(x)$: $x$ 是哺乳动物</li><li>$q(x)$: $x$ 是脊椎动物</li><li>$r(x)$: $x$ 是胎生动物</li></ul><p>前提：$\forall x(p(x)\rightarrow q(x)),\neg \forall x(p(x)\rightarrow r(x))$<br>结论：$\exists x(q(x)\wedge \neg r(x))$</p><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$\neg \forall x(p(x)\rightarrow r(x))$</td><td>前提引入</td></tr><tr><td>2</td><td>$\exists x\neg (p(x)\rightarrow r(x))$</td><td>1，量词否定转换</td></tr><tr><td>3</td><td>$\neg (p(c)\rightarrow r(c))$</td><td>2，$EI$存在量词消去</td></tr><tr><td>4</td><td>$\neg(\neg p(c)\vee r(c))$</td><td>3，置换规则（等值演算）</td></tr><tr><td>5</td><td>$p(c)\wedge \neg r(c)$</td><td>4，置换规则</td></tr><tr><td>6</td><td>$\neg r(c)$</td><td>5，化简律</td></tr><tr><td>7</td><td>$\forall x(p(x)\rightarrow q(x))$</td><td>前提引入</td></tr><tr><td>8</td><td>$p(c)\rightarrow q(c)$</td><td>7，$UI$</td></tr><tr><td>9</td><td>$p(c)$</td><td>5，化简律</td></tr><tr><td>10</td><td>$q(c)$</td><td>8，9 ，假言推理</td></tr><tr><td>11</td><td>$q(c)\wedge \neg r(c)$</td><td>6，10 ，合取</td></tr><tr><td>12</td><td>$\exists x(q(x)\wedge \neg r(x))$✔️</td><td>11，$EG$存在量词引入</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$UI$(全称量词消去规则)：$\forall xA(x)\Rightarrow A(x)$&lt;/li&gt;
&lt;li&gt;$EI$(存在量词消去规则)：$\exists xA(x)\Rightarrow A(c)$&lt;/li&gt;
&lt;li&gt;$UG$(全称量词引入规则)：$A(y)\Rightarrow \forall x A(x)$, $y$ 为任意值， $A(y)$ 为真&lt;/li&gt;
&lt;li&gt;$EG$(存在量词引入规则)：$A(c)\Rightarrow \exists xA(x)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Math" scheme="https://www.ccyh.xyz/categories/Math/"/>
    
    
      <category term="Math" scheme="https://www.ccyh.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>谓词逻辑</title>
    <link href="https://www.ccyh.xyz/p/5e79.html"/>
    <id>https://www.ccyh.xyz/p/5e79.html</id>
    <published>2020-03-06T13:55:13.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><blockquote><p>$def:$ </p><ul><li>个体词：可独立存在的客体</li><li>谓词：用来说明个体的性质或个体间的关系</li></ul></blockquote><a id="more"></a><p><strong>如：</strong> 小明是个小学生<br>其中，<code>小明</code> 就是个体词，<code>是个小学生</code> 就是谓词, 说明了客体的性质。<br><strong>再如：</strong> $6$ 大于 $5$<br>其中 6 与 5 为个体词，<code>大于</code> 为谓词，说明了客体间的关系。</p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>例1：</strong> 写命题的谓词表达式：</p><p><1> 小明是个小学生<br>设 $A(x)$:$x$ 为小学生，$a$:小明<br>则命题符号化为：$A(a)$</1></p><p><2> $6$ 大于 $5$<br>设 $H(x,y)$:$x$ 大于 $y$, $a:6,b:5$<br>则命题符号化为：$H(a,b)$</2></p><p>其中：</p><ul><li>$A(x)$ 为一元谓词； $H(x,y)$ 为二元谓词</li><li>$A(a)$ 为一元谓词常项； $H(a,b)$ 为二元谓词常项</li></ul><hr><h2 id="引入量词"><a href="#引入量词" class="headerlink" title="引入量词"></a>引入量词</h2><blockquote><p>$def:$ 个体域：个体变动的取值范围(类似于函数的定义域)</p></blockquote><blockquote><p>$def:$ 量词： 表示个体之间数量关系的词</p><ul><li>全称量词：符号 “ $\forall$ “ : 任意的 $x$</li><li>存在量词：符号 “ $\exists$ “ : 存在这样的 $x$</li></ul></blockquote><p><strong>例2：</strong> 用谓词逻辑将下列命题符号化：</p><p><1> 所有的偶数均能够被 2 整除。<br>设 $A(x)$: $x$ 为偶数， $B(x)$: $x$ 能被 2 整除<br>则命题符号化为：$\forall x(A(x)\rightarrow B(x))$</1></p><p><2> 有一些人登上过月球。<br>设 $A(x)$: $x$ 为人， $B(x)$: $x$ 登上过月球<br>则命题符号化为：$\exists x (A(x)\wedge B(x))$</2></p><p><3> 每列火车都比某些汽车快。<br>设 $F(x)$: $x$ 是火车， $G(x)$: $x$ 是汽车，$H(x,y)$: $x$ 比 $y$ 快<br>则命题符号化为：$\forall x(F(x)\rightarrow \exists y(G(y)\wedge H(x,y))$</3></p><p><4> 没有不犯错的人<br>设 $A(x)$ : $x$ 为人， $B(x)$: $x$ 犯过错<br>则命题符号化为：$\neg \exists x(A(x)\wedge \neg B(x))$</4></p><blockquote><p>⚠️总结：不难发现</p><ul><li>全称量词 “ $\forall$ “ 后加 $\rightarrow$</li><li>存在量词 “ $\exists$ “ 后加 $\wedge$</li></ul></blockquote><hr><blockquote><p>$def:$ </p><ul><li>量词的指导变元：$\forall /\exists + (x,y,z,…)$</li><li>量词的辖域： 量词的作用范围 $\forall /\exists x + (D)$, $D$ 即为辖域</li><li>变元由可分为：约束变元、自由变元</li></ul></blockquote><p>对于下述公式：<br>$$<br>\forall \color{red}{x}\exists \color{blue}{y}   (P(\color{red}{x},\color{blue}{y})\wedge Q(\color{blue}{y},z)) \wedge \exists \color{green}{x}R(\color{green}{x},\color{yellow}{y})<br>$$<br>其中：</p><ul><li>$\color{red}{x},\color{blue}{y}$ 的辖域为：$(P(\color{red}{x},\color{blue}{y}) \wedge Q(\color{blue}{y},z))$</li><li>$\color{green}{x}$ 的辖域为：$R(\color{green}{x},\color{yellow}{y})$</li><li>$\color{red}{x},\color{blue}{y},\color{green}{x}$ 为约束变元</li><li>$\color{yellow}{y},z$ 为自由变元</li></ul><blockquote><p>$def:$ 设 $A$ 和 $B$ 是任意两个谓词公式，如果 $A\rightarrow B$ 是重言式，称 $A$ 与 $B$ 等价，记为：$A\Leftrightarrow B$</p></blockquote><p>⭐️需要熟记的等价式：</p><ol><li><p>命题逻辑中的等价式的代换实例是谓词逻辑中的等值式<br>如：$A\rightarrow B \Leftrightarrow \neg A\vee B$ 相当于 $P(x)\rightarrow Q(x)\Leftrightarrow \neg P(x)\vee Q(x)$; 且 $\neg (A\wedge B)\Leftrightarrow \neg A\vee \neg B$ 相当于 $\neg(\exists xP(x)\wedge \forall xQ(x))\Leftrightarrow \neg \exists xP(x)\vee \neg \forall xQ(x)$</p></li><li><p>量词否定转换<br>$\neg \forall xP(x) \Leftrightarrow \exists x\neg P(x)$<br>$\neg \exists xP(x) \Leftrightarrow \forall x\neg P(x)$</p></li><li><p>量词辖域的扩张和收缩、<br>$\forall x(A(x)\wedge \exists y B(y))\Leftrightarrow \forall xA(x) \wedge \exists y B(y)$ 收缩</p></li><li><p>量词分配律<br>$\color{red}{\forall} x(A(x)\color{red}{\wedge} B) \Leftrightarrow \forall xA(x) \wedge \forall x B(x)$<br>$\color{green}{\exists} x(A(x)\color{green}{\vee} B) \Leftrightarrow \exists xA(x) \vee \exists x B(x)$<br>⚠️这里要注意的是只有当全称量词与合取符号，存在量词与析取符号两种情况时分配律才有效。</p></li></ol><p><strong>例3：</strong> 设个体域 $D = { a,b,c }$, 消去谓词公式中的量词</p><p><1> $\exists xF(x) \rightarrow \forall yG(y)$<br>消去后：$F(a)\vee F(b)\vee F(c) \rightarrow G(a)\wedge G(b) \wedge G(c)$</1></p><p><2> $\forall x\forall y(F(x)\rightarrow G(y))$<br>$\Leftrightarrow \forall x(F(x)\rightarrow \forall yG(y))$<br>$\Leftrightarrow \forall x(\neg F(x) \vee \forall y G(y))$<br>$\Leftrightarrow \forall x\neg F(x) \vee \forall yG(y)$; (x 辖域收缩)<br>$\Leftrightarrow \neg \exists xF(x)\vee \forall yG(y)$;(量词否定转换)<br>$\Leftrightarrow \exists xF(x)\rightarrow \forall yG(y)$;(等价式)<br>$\Leftrightarrow (F(a)\vee F(b)\vee F(c))\rightarrow (G(a)\wedge G(b)\wedge G(c))$</2></p><h3 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h3><blockquote><p>$def:$ 一个谓词公式 $A$ , 若具有形式 $Q_1x_1Q_2x_2Q_3x_3 \cdots Q_nx_nM$ 其中每个$Q_i$ 为量词 $(\forall / \exists)$, $M$ 为不含量词的公式，则称 $A$ 为<strong>前束范式</strong>。</p></blockquote><p><strong>例4：</strong> 求谓词公式的前束范式</p><p><1> $\neg \forall x(F(x)\rightarrow G(x))$<br>$\Leftrightarrow \exists x\neg(F(x)\rightarrow G(x))$<br>或 $\Leftrightarrow \exists x\neg (\neg F(x)\vee G(x))$<br>或 $\Leftrightarrow \exists x(F(x)\wedge G(x))$</1></p><p><2> $\forall xF(x)\wedge \forall y G(y)$<br>$\Leftrightarrow \forall x \forall y(F(x)\wedge G(y))$<br>$\Leftrightarrow \forall xF(x)\wedge \forall x G(x)$ 换名规则<br>$\forall x(F(x)\wedge G(x))$</2></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;谓词&quot;&gt;&lt;a href=&quot;#谓词&quot; class=&quot;headerlink&quot; title=&quot;谓词&quot;&gt;&lt;/a&gt;谓词&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;$def:$ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个体词：可独立存在的客体&lt;/li&gt;
&lt;li&gt;谓词：用来说明个体的性质或个体间的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Math" scheme="https://www.ccyh.xyz/categories/Math/"/>
    
    
      <category term="Math" scheme="https://www.ccyh.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>命题逻辑的推理规则</title>
    <link href="https://www.ccyh.xyz/p/9694.html"/>
    <id>https://www.ccyh.xyz/p/9694.html</id>
    <published>2020-03-06T09:58:38.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99/20200306100822156.png" alt="推理过程"><br></center><p>$def:$ 设 $A$ 和 $B$ 是两个命题公式，当且仅当 $A\rightarrow B$ 是 <strong>重言式</strong> 时称由 $A$ 可推出 $B$ ,或 $B$ 是前提 $A$ 的结论，记为：$A\Rightarrow B$,读作如果 $A$ 为真那么 $B$ 为真。</p><a id="more"></a><h3 id="推理方法"><a href="#推理方法" class="headerlink" title="推理方法"></a>推理方法</h3><p>证明前提 $A$ 推出结论 $B$ 的方法有三种：</p><ul><li>真值表法</li><li>等值演算法(利用等值式)</li><li><strong>在自然推理系统 $P$ 中用推理规则证明</strong>（重点）</li></ul><h4 id="推理规则："><a href="#推理规则：" class="headerlink" title="推理规则："></a>推理规则：</h4><p>以下规则虚熟记于心,下述<code>逗号</code>可以理解成 <strong>并且</strong></p><ul><li>化简律：$p\wedge q\Rightarrow p, p\wedge q\Rightarrow q$；</li><li>附加律：$p\Rightarrow p\vee q,q\Rightarrow p\vee q$</li><li>假言推理：$p, p\rightarrow q \Rightarrow q$</li><li>拒取式：$p\rightarrow q,\neg q\Rightarrow \neg p$</li><li>析取三段论：$p\vee q,\neg p\Rightarrow q$</li><li>合取式：$p,q\Rightarrow p\wedge q$</li><li>假言三段论：$p\rightarrow q,q\rightarrow r\Rightarrow p\rightarrow r$ (传递性)</li><li>等价三段论：$p\leftrightarrow q,q\leftrightarrow r\Rightarrow p\leftrightarrow r$(传递性)</li><li>构造性二难：$p\rightarrow q,r\rightarrow s,p\vee r \Rightarrow q\vee s$</li><li>归结式：$p\vee q,\neg p\vee s \Rightarrow q\vee s$</li></ul><h4 id="推理证明的一般步骤："><a href="#推理证明的一般步骤：" class="headerlink" title="推理证明的一般步骤："></a>推理证明的一般步骤：</h4><p><strong>例1：</strong>证明下述式子：<br>$$<br>(p\vee q)\wedge(p\leftrightarrow r)\wedge(q\rightarrow s)\Rightarrow s\vee r<br>$$<br>$proof:$ 下表置换规则值得就是利用<code>等值式</code>进行等值演算得到的结论</p><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$p\vee q$</td><td>前提引入</td></tr><tr><td>2</td><td>$\neg p\rightarrow q$</td><td>1，置换规则</td></tr><tr><td>3</td><td>$q\rightarrow s$</td><td>前提引入</td></tr><tr><td>4</td><td>$\neg p\rightarrow s$</td><td>2,3，假言三段论</td></tr><tr><td>5</td><td>$\neg s\rightarrow p$</td><td>4，置换规则</td></tr><tr><td>6</td><td>$p\leftrightarrow r$</td><td>前提引入</td></tr><tr><td>7</td><td>$(p\rightarrow r)\wedge(r\rightarrow p)$</td><td>6，置换规则</td></tr><tr><td>8</td><td>$p\rightarrow r$</td><td>7，化简律</td></tr><tr><td>9</td><td>$\neg s\rightarrow r$</td><td>5,8，假言三段论</td></tr><tr><td>10</td><td>$\color{green}{s\vee r}$</td><td>9，置换规则</td></tr></tbody></table><p><strong>例2：</strong> 给出下述推论的形式化证明</p><ul><li>若马会飞或羊吃草，则母鸡就会变飞鸟；</li><li>如果母鸡变飞鸟，那么烤熟的鸭子还会跑；</li><li>烤熟的鸭子不会跑，所以羊儿不吃草。</li></ul><p>$proof:$<br>命题符号化：找到原子命题<br>令：</p><ul><li>$p$：马会飞</li><li>$q$：羊吃草</li><li>$r$：母鸡变飞鸟</li><li>$s$：烤熟的鸭子还会跑</li></ul><p>故上述命题符号化为：<br>前提：$(p\vee q)\rightarrow r,r\rightarrow s,\neg s$<br>结论：$\neg q$</p><p><strong>一般证明法：</strong></p><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$\neg s$</td><td>前提引入</td></tr><tr><td>2</td><td>$r\rightarrow s$</td><td>前提引入 </td></tr><tr><td>3</td><td>$\neg r$</td><td>1,2 拒取式</td></tr><tr><td>4</td><td>$p\vee q\rightarrow r$</td><td>前提引入</td></tr><tr><td>5</td><td>$\neg(p\vee q)$</td><td>3,4 拒取式</td></tr><tr><td>6</td><td>$\neg p\wedge \neg q$</td><td>5，置换规则</td></tr><tr><td>7</td><td>$\neg q$ ✅</td><td>6，化简律</td></tr></tbody></table><p><strong>⚡️用归谬法(反证法)证明：</strong><br>🔅思想：将结论否定，在由此推出矛盾</p><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$\neg\neg q$</td><td>附加前提引入，假设羊儿吃草</td></tr><tr><td>2</td><td>$q$</td><td>1，置换规则 </td></tr><tr><td>3</td><td>$p\vee q$</td><td>2,附加律</td></tr><tr><td>4</td><td>$p\vee q\rightarrow r$</td><td>前提引入</td></tr><tr><td>5</td><td>$r$</td><td>3,4 假言推理</td></tr><tr><td>6</td><td>$r\rightarrow s$</td><td>前提引入</td></tr><tr><td>7</td><td>$s$</td><td>5，6 假言推理</td></tr><tr><td>8</td><td>$\neg s$</td><td>前提引入</td></tr><tr><td>9</td><td>$\color{red}{s \wedge \neg s}$</td><td>7,8 合取（❌出现矛盾，假设不成立）</td></tr></tbody></table><p><strong>例3：</strong> 🌞用<strong>附加前提法</strong>证明下述命题：</p><ul><li>如果小张和小王去看电影，则小李也去看电影；</li><li>小赵不去看电影或小张不去看电影，小王去看电影；</li><li>所以当小赵去看电影时，小李也去看电影。</li></ul><p>$proof:$<br>命题符号化：找到原子命题<br>令：</p><ul><li>$p$：小张去看电影</li><li>$q$：小王去看电影</li><li>$r$：小李去看电影</li><li>$s$：小赵去看电影</li></ul><p>前提：$p\wedge q\rightarrow r,\neg s\vee p,q$<br>结论：$s\rightarrow r$</p><blockquote><p>⭐️附加前提法：<br>若结论为 $s\rightarrow r$ ,可以把 $s$ 放到前提中，推证 $r$ 成立即可。</p></blockquote><table><thead><tr><th>步骤</th><th>公式</th><th>理由</th></tr></thead><tbody><tr><td>1</td><td>$s$</td><td>附加前提引入</td></tr><tr><td>2</td><td>$\neg s \vee p$</td><td>前提引入</td></tr><tr><td>3</td><td>$p$</td><td>1，2，析取三段论</td></tr><tr><td>4</td><td>$q$</td><td>前提引入</td></tr><tr><td>5</td><td>$p\wedge q$</td><td>3,4 合取</td></tr><tr><td>6</td><td>$p\wedge q\rightarrow r$</td><td>前提引入</td></tr><tr><td>7</td><td>$r$</td><td>5，6 假言推理</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;推理&quot;&gt;&lt;a href=&quot;#推理&quot; class=&quot;headerlink&quot; title=&quot;推理&quot;&gt;&lt;/a&gt;推理&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99/20200306100822156.png&quot; alt=&quot;推理过程&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;$def:$ 设 $A$ 和 $B$ 是两个命题公式，当且仅当 $A\rightarrow B$ 是 &lt;strong&gt;重言式&lt;/strong&gt; 时称由 $A$ 可推出 $B$ ,或 $B$ 是前提 $A$ 的结论，记为：$A\Rightarrow B$,读作如果 $A$ 为真那么 $B$ 为真。&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="https://www.ccyh.xyz/categories/Math/"/>
    
    
      <category term="Math" scheme="https://www.ccyh.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>命题逻辑基础</title>
    <link href="https://www.ccyh.xyz/p/4375.html"/>
    <id>https://www.ccyh.xyz/p/4375.html</id>
    <published>2020-03-05T12:09:20.000Z</published>
    <updated>2020-05-06T09:06:17.427Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><p><strong>命题：</strong>能判断真假的陈述句</p><ul><li>命题常量：$p$：小明是个男生(已指定了命题)</li><li>命题变量：$p$：（未指定命题）</li></ul><a id="more"></a><p><strong>真值：</strong> 真，假<br><strong>命题分类：</strong> 真命题、假命题、简单命题(原子命题)、复合命题<br><strong>命题公式：</strong></p><ul><li>重言式：真值恒为 1 （永真式）</li><li>矛盾式：真值恒为 0 （永假式）</li><li>可满足式：不是矛盾式的都是</li></ul><h2 id="命题逻辑中的基本联结词"><a href="#命题逻辑中的基本联结词" class="headerlink" title="命题逻辑中的基本联结词"></a>命题逻辑中的基本联结词</h2><p>$\neg$ : 否定（非）<br>$\wedge$ : 合取（与）<br>$\vee$ : 析取（或）<br>$\rightarrow$ : 蕴含（if … then …）<br>$\leftrightarrow$: 等价(当且仅当)</p><h3 id="真值表："><a href="#真值表：" class="headerlink" title="真值表："></a>真值表：</h3><p>与或非的简单真值表就不再赘述了，主要看蕴含和等价</p><table><thead><tr><th>$p \qquad q$</th><th>$p\rightarrow q$</th><th>$p\leftrightarrow q$  </th></tr></thead><tbody><tr><td> 0 $\qquad$ 0</td><td>1</td><td>1</td></tr><tr><td> 0 $\qquad$ 1</td><td>1</td><td>0</td></tr><tr><td> 1 $\qquad$ 0</td><td>0</td><td>0</td></tr><tr><td> 1 $\qquad$ 1</td><td>1</td><td>1</td></tr></tbody></table><p>例：判断公式$p\wedge r \wedge \neg(q\rightarrow p)$的类型（真值表法）</p><table><thead><tr><th>$p \quad q \quad r$</th><th>$p\wedge r$</th><th>$p\rightarrow q$</th><th>$\neg(p\rightarrow q)$</th><th>$p\wedge r\wedge \neg(p\rightarrow q)$  </th></tr></thead><tbody><tr><td> $0 \quad 0 \quad 0$</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td> $0 \quad 0 \quad 1$</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td> $0 \quad 1 \quad 0$</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td> $0 \quad 1 \quad 1$</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td> $1 \quad 0 \quad 0$</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td> $1 \quad 0 \quad 1$</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td> $1 \quad 1 \quad 0$</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td> $1 \quad 1 \quad 1$</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>故该式为矛盾式（永假式）<br>例0：求公式 $(\neg p \wedge q)\rightarrow \neg r$的成真赋值和成假赋值（同上，真值表法）</p><h2 id="命题逻辑的等值演算"><a href="#命题逻辑的等值演算" class="headerlink" title="命题逻辑的等值演算"></a>命题逻辑的等值演算</h2><p><strong>等值式：</strong>若$A\leftrightarrow B$是重言式，则可称A和B等值，记作$A&lt;=&gt;B$，读作<code>逻辑等价于</code><br><strong>基本等值式：</strong></p><ul><li>交换律：$A\vee B &lt;=&gt; B\vee A; A\wedge B &lt;=&gt; B\wedge A$</li><li>结合律：$(A\vee B)\vee C &lt;=&gt; A\vee (B\vee C)$</li><li>分配律：$A\vee (B\wedge C)&lt;=&gt;(A\vee B)\wedge (A\vee C)$</li><li>双重否定律：$\neg\neg A &lt;=&gt; A$</li><li>等幂律：$A&lt;=&gt;A\vee A;A&lt;=&gt;A\wedge A$</li><li>摩根律：$\neg (A\vee B)&lt;=&gt;\neg A \wedge \neg B;\neg(A\wedge B)&lt;=&gt;\neg A\vee \neg B$</li><li>吸收律：$A\vee (A\wedge B)&lt;=&gt;A;A\wedge (A\vee B)&lt;=&gt;A$</li><li>同一律：$A\vee 0&lt;=&gt;A; A\wedge 1 &lt;=&gt; A$</li><li>零律：$A\vee 1 &lt;=&gt; 1;A\wedge 0&lt;=&gt;0$</li><li>排中律：$A\vee \neg A&lt;=&gt;1$</li><li>矛盾律：$A\wedge \neg A&lt;=&gt;0$</li><li><strong>蕴含等值式</strong>：$A \rightarrow B &lt;=&gt; \neg A\vee B$，若A则B为真，则非A和B二者肯定有一个字真的</li><li><strong>等价等值式</strong>：$A\leftrightarrow B&lt;=&gt;(A\rightarrow B)\wedge (B\rightarrow A)$ </li><li>假言易位式：$A\rightarrow B &lt;=&gt; \neg B\rightarrow \neg A$,即逆否命题</li><li>等价否定等值式：$A \leftrightarrow B &lt;=&gt; \neg A \leftrightarrow \neg B$</li><li>归谬论：$(A\rightarrow B)\wedge (A\rightarrow \neg B)&lt;=&gt;\neg A$</li></ul><p>牢记上述基本等值式，以用来进行对复杂等值式的等值演算，比如现在我们用上述公式来证明一下归谬论：</p><blockquote></blockquote><p>$$(A\rightarrow B)\wedge (A\rightarrow \neg B)&lt;=&gt;\neg A$$<br>左边 $=(A\rightarrow B)\wedge (A\rightarrow \neg B)$<br>$&lt;=&gt; \neg A\vee B\wedge (\neg A\vee \neg B)$ &emsp;利用蕴含等值式得到<br>$&lt;=&gt; \neg A \vee ((B\wedge \neg A)\vee (B\wedge \neg B))$ &emsp;利用分配律得到<br>$&lt;=&gt; \neg A\vee (B\wedge \neg A)$ &emsp;利用矛盾律得到<br>$&lt;=&gt; \neg A = $右边  &emsp;利用吸收律得到<br>思路： 用等值式去掉$\rightarrow,\leftrightarrow$ 联结词，换成只含有$\neg ,\vee ,\wedge$的尽量简洁的式子。</p><h2 id="析取范式、合取范式"><a href="#析取范式、合取范式" class="headerlink" title="析取范式、合取范式"></a>析取范式、合取范式</h2><p>$def1:$ $p$ 为任意命题变量，则 $p$ 和 $\neg p$ 称为<code>文字</code><br>$def2:$ 有限个文字的析取称为析取式；有限个文字的合取称为合取式<br>$def3:$ </p><ul><li>有限个合取式的析取称为析取范式，如$(p_1\wedge q_1)\vee(p_2\wedge q_2)\vee … \vee(p_n\wedge q_n)$; </li><li>有限个析取式的合取称为合取范式，如$(p_1\vee q_1)\wedge(p_2\vee q_2)\wedge … \wedge(p_n\vee q_n)$;</li></ul><h2 id="主析取范式、主合取范式"><a href="#主析取范式、主合取范式" class="headerlink" title="主析取范式、主合取范式"></a>主析取范式、主合取范式</h2><p>$def1:$ 含有$n$个命题变量的 <strong>合取式</strong> $G(p_1,p_2,…,p_n)$若每个 $p_i$ 和 $\neg p_i$ 出现且仅出现一次，而且出现次序与 $p_1,p_2,…,p_n$ 的次序保持一致，则称该式 $G(p_1,p_2,…,p_n)$ 为一个<strong>小项</strong>。而对于一个<strong>析取范式</strong> $A_1 \vee A_2 \vee … \vee A_n$, 若其中的每一个合取范式 $A_i$ 都是<strong>小项</strong>，则称该析取范式为<strong>主析取范式</strong>。</p><p>$def2:$ 含有$n$个命题变量的 <strong>析取式</strong> $G(p_1,p_2,…,p_n)$若每个 $p_i$ 和 $\neg p_i$ 出现且仅出现一次，而且出现次序与 $p_1,p_2,…,p_n$ 的次序保持一致，则称该式 $G(p_1,p_2,…,p_n)$ 为一个<strong>大项</strong>。而对于一个<strong>合取范式</strong> $A_1 \wedge A_2 \wedge … \wedge A_n$, 若其中的每一个析取范式 $A_i$ 都是<strong>大项</strong>，则称该析取范式为<strong>主合取范式</strong>。<br><strong>结合例子来学习上述定义：</strong></p><p>例1：求 $p \rightarrow q$ 的主合取范式和主析取范式</p><blockquote><p>法一：真值表法（不妨先求主析取）</p><ol><li>先写小项</li><li>写小项的成真赋值</li><li>找出使$p\rightarrow q$为真的小项，将它们析取<br>同理若求主合取则先写大项，写大项的成假赋值，找出使$p\rightarrow q$为假的小项，将它们合取</li></ol></blockquote><table><thead><tr><th>小项</th><th>成真赋值</th><th>$p\rightarrow q$</th><th>是否为真  </th></tr></thead><tbody><tr><td>$\neg p\wedge \neg q$</td><td>$0 \qquad 0$</td><td>1</td><td>是</td></tr><tr><td>$\neg p\wedge q$</td><td>$0 \qquad 1$</td><td>1</td><td>是</td></tr><tr><td>$p\wedge \neg q$</td><td>$1 \qquad 0$</td><td>0</td><td>否</td></tr><tr><td>$p\wedge q$</td><td>$1 \qquad 1$</td><td>1</td><td>是</td></tr></tbody></table><p>故主析取范式为：<br>$$<br>p\rightarrow q &lt;=&gt; (\neg p\wedge \neg q)\vee (\neg p\wedge q)\vee ( p\wedge q)<br>$$<br>主合取范式为：(找$p\rightarrow q$为假时的小项对应的大项再将它们合取)<br>$$<br>p\rightarrow q &lt;=&gt; \neg p \vee q<br>$$<br>法二：等值演算法(常用)<br>左边$ = p\rightarrow q$<br>$&lt;=&gt; \neg p \vee q$ 主合取范式（蕴含等值式）<br>$&lt;=&gt; (\neg p \wedge \color{red}{(q\vee \neg q)})\vee (\color{red}{(p \vee \neg p)}\wedge q)$ (由排中律构造)<br>$&lt;=&gt; \color{green}{(\neg p \wedge q)}\vee(\neg p \wedge \neg q)\vee( p \wedge q)\vee \color{green}{(\neg p \wedge q)}$<br>$&lt;=&gt; \color{green}{(\neg p \wedge q)}\vee(\neg p \wedge \neg q)\vee( p \wedge q)$ 主析取范式(幂等律)</p><p>再看一个稍微复杂点的例子<br>例2：求 $p \rightarrow ((p\rightarrow q)\wedge \neg (\neg q \vee \neg p))$ 的主合取范式<br>$proof:$<br>左边$ =p \rightarrow ((p\rightarrow q)\wedge \neg (\neg q \vee \neg p))$<br>$&lt;=&gt; \neg p \vee ((\neg p \vee q)\wedge (q\wedge p))$ (蕴含等价)<br>$&lt;=&gt; (\neg p \vee(\neg p \vee q))\wedge (\neg p \vee (q \wedge p))$<br>$&lt;=&gt; (\neg p \vee q)\wedge (\neg p \vee q)\wedge (\neg p \vee p)$(摩根律)<br>$&lt;=&gt; (\neg p \vee q)\wedge (\neg p \vee q)&lt;=&gt;(\neg p \vee q)$ 主合取式(等幂律)</p><hr><h2 id="联结词的完备集-neg-vee-wedge-rightarrow-leftrightarrow"><a href="#联结词的完备集-neg-vee-wedge-rightarrow-leftrightarrow" class="headerlink" title="联结词的完备集 $(\neg \vee \wedge \rightarrow \leftrightarrow)$"></a>联结词的完备集 $(\neg \vee \wedge \rightarrow \leftrightarrow)$</h2><p>$def:$ $S$ 是一个联结词集合，若任意一个命题公式都可以由 $S$ 中的额联结词表示出来且命题公式与之等价，则称 $S$ 为一个联结词的<strong>完备集</strong>。<br>$Th:$ 以下联结词的集合都是一个联结词完备集：</p><ul><li>$S_1 = { \neg, \vee, \wedge }$</li><li>$S_2 = { \neg, \vee, \wedge, \rightarrow }$</li><li>$S_3 = { \neg, \vee, \wedge, \rightarrow, \leftrightarrow }$</li><li>$S_4 = { \neg, \wedge }$</li><li>$S_5 = { \neg, \vee }$</li><li>$S_6 = { \neg, \rightarrow }$</li><li>$S_7 = { \uparrow }$ 与非 $p \uparrow q &lt;=&gt; \neg(p\wedge q)$</li><li>$S_8 = { \downarrow }$ 或非 $p \downarrow q &lt;=&gt; \neg(p \vee q)$</li></ul><p>来看一个对应知识的例题<br>例3：将 $p\rightarrow q$ 分别化成上述 $S_4,S_5,S_7,S_8$ 集合上的公式<br>$Proof:$<br>$p\rightarrow q &lt;=&gt; \neg p \vee q$  ———————————$S_5$<br>$&lt;=&gt; \neg\neg(\neg p \vee q)&lt;=&gt; \neg(p \wedge \neg q)$——$S_4$<br>$&lt;=&gt; p\uparrow \neg q&lt;=&gt;p\uparrow(\neg q\vee \neg q)&lt;=&gt;p\uparrow\neg(q\wedge q)&lt;=&gt;p\uparrow(q\uparrow q)$—–$S_7$<br>$p\rightarrow q&lt;=&gt;\neg\neg(\neg p\vee q)&lt;=&gt;\neg(\neg p\downarrow q)&lt;=&gt;\neg(p\downarrow p\downarrow q)$<br>$&lt;=&gt;(p\downarrow p\downarrow q)\downarrow(p\downarrow p\downarrow q)$—$S_8$</p><hr><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;命题&quot;&gt;&lt;a href=&quot;#命题&quot; class=&quot;headerlink&quot; title=&quot;命题&quot;&gt;&lt;/a&gt;命题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命题：&lt;/strong&gt;能判断真假的陈述句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命题常量：$p$：小明是个男生(已指定了命题)&lt;/li&gt;
&lt;li&gt;命题变量：$p$：（未指定命题）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mathematics" scheme="https://www.ccyh.xyz/categories/Mathematics/"/>
    
    
      <category term="discretemathematics" scheme="https://www.ccyh.xyz/tags/discretemathematics/"/>
    
  </entry>
  
  <entry>
    <title>【闲疯帝】EasyX康威生命游戏的简单实现</title>
    <link href="https://www.ccyh.xyz/p/20c.html"/>
    <id>https://www.ccyh.xyz/p/20c.html</id>
    <published>2020-02-05T11:38:22.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><hr><p>生命游戏中，对于任意细胞，规则如下：</p><p>&emsp;每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）<br><a id="more"></a></p><ul><li>当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态。（模拟生命数量稀少）</li><li>当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。</li><li>当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）<br>*当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）</li></ul><p>可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。<code>[From WikiPedia]</code></p><hr><h2 id="简单实现（采用EasyX绘图库）"><a href="#简单实现（采用EasyX绘图库）" class="headerlink" title="简单实现（采用EasyX绘图库）"></a>简单实现（采用EasyX绘图库）</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 30</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">康威生命游戏的c++简单实现</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;(N, <span class="hljs-string">' '</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">清屏函数：若使用system("cls")会出现闪屏，因为该函数太慢了</span></span><br><span class="line"><span class="hljs-comment">由于数据量不大这里采用移动光标实现屏幕部分涂改，也可采用双缓冲机制(自行google)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearScreen</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">COORD coordScreen = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;</span><br><span class="line">SetConsoleCursorPosition(hConsole, coordScreen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 判断周围生命个数</span></span><br><span class="line"><span class="hljs-keyword">int</span> direct[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125; &#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countLiveFunc</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> nx, ny;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">nx = x + direct[k][<span class="hljs-number">0</span>];</span><br><span class="line">ny = y + direct[k][<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; N &amp;&amp; board[nx][ny] == <span class="hljs-string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 刷新函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fresh</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> n = board.size();</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; newBoard(board);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> countLive = countLiveFunc(board, i, j);</span><br><span class="line"><span class="hljs-keyword">if</span> (countLive &lt; <span class="hljs-number">2</span>) newBoard[i][j] = <span class="hljs-string">' '</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countLive == <span class="hljs-number">2</span> || countLive == <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countLive &gt; <span class="hljs-number">3</span>) newBoard[i][j] = <span class="hljs-string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> countLive = countLiveFunc(board, i, j);</span><br><span class="line"><span class="hljs-keyword">if</span> (countLive == <span class="hljs-number">3</span>) newBoard[i][j] = <span class="hljs-string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">board = newBoard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printBoard</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">initgraph(<span class="hljs-number">700</span>, <span class="hljs-number">600</span>); <span class="hljs-comment">// 初始化窗口</span></span><br><span class="line">setbkcolor(WHITE);</span><br><span class="line">setfillcolor(GREEN);</span><br><span class="line">setlinecolor(BLACK);</span><br><span class="line"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;</span><br><span class="line">BeginBatchDraw();<span class="hljs-comment">// 开始绘图，下面绘制的图形暂时不会显示出来</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : board)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i == <span class="hljs-string">' '</span>) rectangle(x, y, x + <span class="hljs-number">20</span>, y + <span class="hljs-number">20</span>);</span><br><span class="line"><span class="hljs-keyword">else</span> fillrectangle(x, y, x + <span class="hljs-number">20</span>, y + <span class="hljs-number">20</span>);</span><br><span class="line">x = (x + <span class="hljs-number">20</span>) % <span class="hljs-number">600</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) y += <span class="hljs-number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FlushBatchDraw(); <span class="hljs-comment">// 显示之前绘制的图形</span></span><br><span class="line">Sleep(<span class="hljs-number">300</span>);</span><br><span class="line">cleardevice();<span class="hljs-comment">// 清屏</span></span><br><span class="line">fresh(board);</span><br><span class="line">&#125;</span><br><span class="line">EndBatchDraw();</span><br><span class="line">getchar();</span><br><span class="line">closegraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">// 初始化：脉冲星</span></span><br><span class="line">board = &#123;</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 执行打印函数</span></span><br><span class="line">printBoard();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/LifeGame/gamegui.gif" alt="脉冲星"><br><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;生命游戏中，对于任意细胞，规则如下：&lt;/p&gt;
&lt;p&gt;&amp;emsp;每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="闲疯帝" scheme="https://www.ccyh.xyz/categories/%E9%97%B2%E7%96%AF%E5%B8%9D/"/>
    
    
      <category term="Borring" scheme="https://www.ccyh.xyz/tags/Borring/"/>
    
  </entry>
  
  <entry>
    <title>图解红黑树</title>
    <link href="https://www.ccyh.xyz/p/5fb.html"/>
    <id>https://www.ccyh.xyz/p/5fb.html</id>
    <published>2020-01-30T10:08:31.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树的基本结构"><a href="#红黑树的基本结构" class="headerlink" title="红黑树的基本结构"></a>红黑树的基本结构</h2><hr><p>&emsp;<strong>红黑树(Red-black tree)</strong> 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，常用于关联数组、字典等。C++ 中的标准关联容器set、multiset、map、multimap内部采用的数据结构就是红黑树。</p><a id="more"></a><p><strong>红黑树的定义：</strong></p><ol><li>每个节点只能是红色的或黑色的</li><li>根节点是黑色的</li><li>每个叶子节点都是黑色的</li><li>如果一个节点是红色的，那么它的孩子节点必须是黑色的</li><li>从任意一个节点到叶子节点经过的黑色节点个数是一样的</li></ol><h2 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h2><hr><p>在介绍红黑树前先了解其等价形式 <strong>2-3 树</strong>，对后面理解红黑树的定义很有帮助。<br><strong>2-3 树 的定义：</strong></p><ol><li>满足二叉搜索树的性质</li><li>节点可以存放一个(<strong>2-节点</strong>)或两个(<strong>3-节点</strong>)关键字</li><li>每个节点有两个或三个孩子节点</li></ol><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130062357515.png" alt="2-3树的两种节点"><br></center><p>学过<code>B-树</code>的会发现其节点与<code>B-树</code>相似，类似三阶<code>B-树</code>。统样，<strong>2-3 树</strong> 的基本操作也与<code>B-树</code>类似。<br><strong>2-3 树 的基本操作：</strong></p><ol><li><strong>插入：</strong> 插入新节点时，往叶子节点插入</li><li><strong>分解：</strong> 4-节点可以被分解成 3 个 2-节点组成的树，且分解后树的根节点要向上与其原来的父节点融合。</li></ol><p>下面按序列<br>$${1,2,3,4,5}$$<br>构建一棵 <strong>2-3 树</strong>：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130064535147.png" alt=""><br></center><p>不难发现在上述操作中 <strong>2-3 树</strong> 始终能够保持严格的平衡。但是由于其节点关键字个数不唯一，且拆分合并操作的编程实现较复杂，因此我们希望通过添加一些规则，将其转化成二叉树，且转换后的二叉树仍然具有2-3树的自平衡优点，这就是红黑树。</p><h2 id="2-3-树-gt-红黑树"><a href="#2-3-树-gt-红黑树" class="headerlink" title="2-3 树 -&gt; 红黑树"></a>2-3 树 -&gt; 红黑树</h2><hr><p>对于 <strong>2-3 树</strong> 的两种结点，有不同的转换规则：</p><ul><li><strong>2-结点：</strong> 直接转换成红黑树的黑节点</li><li><strong>3-节点：</strong> 拆开两个关键字，左关键字标红（表示红色节点与其父节点在2-3树中曾经是同级关系），右关键字标黑，右关键字作左关键字的父节点</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130071511715.png" alt="节点转化"><br></center><p>按照上述规则，我们将序列<br>$${3,5,8,10,12,15,16,18,19,4,20}$$<br>构建的 <strong>2-3 树</strong> 转化为一棵红黑树：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130074524660.png" alt="2-3树 转 红黑树"><br></center><p>回顾一下红黑树的性质, 判断上图的树是否满足所有性质：</p><ul><li style="list-style: none"><input type="checkbox" checked> 每个节点只能是红色的或黑色的</li><li style="list-style: none"><input type="checkbox" checked> 根节点是黑色的</li><li style="list-style: none"><input type="checkbox"> 每个叶子节点都是黑色的</li><li style="list-style: none"><input type="checkbox" checked> 如果一个节点是红色的，那么它的孩子节点必须是黑色的</li><li style="list-style: none"><input type="checkbox" checked> 从任意一个节点到叶子节点经过的黑色节点个数是一样的</li></ul><p>可以发现除了第三个性质其余都满足了。事实上，性质三中说的叶子节点指的是为空的叶子节点，所以，完整的红黑树应为：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130075833445.png" alt=""><br></center><p>如此一来，便使得所有性质都满足了。</p><hr><h2 id="红黑树的创建"><a href="#红黑树的创建" class="headerlink" title="红黑树的创建"></a>红黑树的创建</h2><hr><p>&emsp;前面提到，创建 <strong>2-3 树</strong> 的代码编写较为复杂，因此我们肯定不会先创建一棵 <strong>2-3树</strong> 再将其转换成红黑树。因为我们可以很方便地创建一棵二叉树，红黑树不过是性质比普通二叉树多了些，因此在创建红黑树时只需在创建二叉树的方法的基础上多加几种操作来保证红黑树的性质不被破坏就行了。</p><p><strong>插入：</strong> 由于前面提到<strong>2-3树</strong>的插入操作都发生在叶子节点，且都是先将待插入元素与该叶子节点融合。因此新插入节点和原位置的叶子节点为平级关系。又前面提到红色节点与其父节点曾是原级关系，故<code>插入节点应为红色</code>。<br><strong>创建演示：</strong> 下图中红边所连接的子节点为我们说的红色节点（《算法 第四版》的说法为红分支所连节点为红节点，类比着看，其实没差别因为一条分支只唯一对应一个结点）。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200131101345963.png" alt=""><br></center><p>观察上述创建过程，发现当插入节点位于右分支时我们需要左旋操作，因为红色节点只能出现在左分支。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130112423899.png" alt="左旋操作"><br></center><p><strong>左旋操作的伪码实现：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode* node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    RBNode *r_temp = node -&gt; right;</span><br><span class="line">    node -&gt; right = r_temp -&gt; left;</span><br><span class="line">    r_temp -&gt; left = node;</span><br><span class="line">    r_temp -&gt; color = node -&gt; color;</span><br><span class="line">    node -&gt; color = RED;</span><br><span class="line">    <span class="hljs-keyword">return</span> r_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>右旋操作与左旋操作类似：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode* node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    RBNode *l_temp = node -&gt; left;</span><br><span class="line">    node -&gt; left = l_temp -&gt; right;</span><br><span class="line">    l_temp -&gt; right = node;</span><br><span class="line">    l_temp -&gt; color = node -&gt; color;</span><br><span class="line">    node -&gt; color = RED;</span><br><span class="line">    <span class="hljs-keyword">return</span> l_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>翻转颜色操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    node -&gt; color = RED;</span><br><span class="line">    node -&gt; left -&gt; color = BLACK;</span><br><span class="line">    node -&gt; right -&gt; color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>插入操作：</strong></p><p>有了上述基本操作的实现基础，我们来研究插入操作的实现。插入按插入位置分三种情况：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/threesituation.png" alt=""><br></center><p><strong>插入操作的实现：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">insert</span><span class="hljs-params">(RBNode *&amp;root, KeyType key, ValueType value)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RBNode(key, value, <span class="hljs-number">1</span>, RED);<span class="hljs-comment">// 插入节点为红色</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(key &lt; root-&gt;key)   root -&gt; left  = insert(root-&gt;left, key, value);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;key)  root -&gt; right = insert(root-&gt;right, key, value);</span><br><span class="line">        <span class="hljs-keyword">else</span>                 root -&gt; value = value;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 应对三种情况的操作</span></span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;left))root = leftRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;left-&gt;left))root = rightRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;right))flipColor(root);</span><br><span class="line"></span><br><span class="line">root -&gt; N = size(root-&gt;left) + size(root-&gt;right) + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RED true</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLACK false</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KeyType int</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ValueType string</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isRed</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">insert</span><span class="hljs-params">(RBNode *&amp;root, KeyType key, ValueType value)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">search</span><span class="hljs-params">(RBNode *root, KeyType key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">RBNode(KeyType k, ValueType v, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">bool</span> c) : key(k), value(v), N(n), color(c), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">KeyType key;<span class="hljs-comment">// 节点保存的键值</span></span><br><span class="line">ValueType value;<span class="hljs-comment">// 键值关联的值</span></span><br><span class="line">RBNode *left, *right;<span class="hljs-comment">// 左右孩子节点指针</span></span><br><span class="line"><span class="hljs-keyword">int</span> N;<span class="hljs-comment">// 这棵子树中的节点数</span></span><br><span class="line"><span class="hljs-keyword">bool</span> color;<span class="hljs-comment">// 节点颜色：真为红，假为黑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 获得以node为根的树的节点数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> node -&gt; N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 获得节点颜色</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRed</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> node-&gt;color == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 改变节点颜色</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">node -&gt; color = RED;</span><br><span class="line">node -&gt; left -&gt; color = BLACK;</span><br><span class="line">node -&gt; right -&gt; color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 左旋操作</span></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">RBNode *temp  = node -&gt; right;</span><br><span class="line">node -&gt; right = temp -&gt; left;</span><br><span class="line">temp -&gt; left  = node;</span><br><span class="line">temp -&gt; color = node -&gt; color;</span><br><span class="line">node -&gt; color = RED;</span><br><span class="line">temp -&gt; N     = node -&gt; N;</span><br><span class="line">node -&gt; N     = <span class="hljs-number">1</span> + size(node-&gt;left) + size(node-&gt;right);</span><br><span class="line"><span class="hljs-keyword">return</span> temp;<span class="hljs-comment">// 返回重置父节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 右旋操作</span></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">RBNode *temp  = node -&gt; left;</span><br><span class="line">node -&gt; left  = temp -&gt; right;</span><br><span class="line">temp -&gt; right = node;</span><br><span class="line">temp -&gt; color = node -&gt; color;</span><br><span class="line">node -&gt; color = RED;</span><br><span class="line">temp -&gt; N     = node -&gt; N;</span><br><span class="line">node -&gt; N     = <span class="hljs-number">1</span> + size(node-&gt;left) + size(node-&gt;right);</span><br><span class="line"><span class="hljs-keyword">return</span> temp;<span class="hljs-comment">// 返回重置父节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">search</span><span class="hljs-params">(RBNode* root, KeyType key)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root -&gt; key == key) <span class="hljs-keyword">return</span> root;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root -&gt; key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> search(root -&gt; left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> search(root -&gt; right, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">insert</span><span class="hljs-params">(RBNode *&amp;root, KeyType key, ValueType value)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RBNode(key, value, <span class="hljs-number">1</span>, RED);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(key &lt; root-&gt;key)   root -&gt; left  = insert(root-&gt;left, key, value);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;key) root -&gt; right = insert(root-&gt;right, key, value);</span><br><span class="line"><span class="hljs-keyword">else</span> root -&gt; value = value;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 应对三种情况的操作</span></span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;left))root = leftRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;left-&gt;left))root = rightRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;right)) flipColor(root);</span><br><span class="line"></span><br><span class="line">root -&gt; N = size(root-&gt;left) + size(root-&gt;right) + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="noopener">《算法》 第四版 - 红黑树</a> - Robert Sedgewick<br><a href="https://mp.weixin.qq.com/s/ccXqujooT4eNvptmJKlmDA" target="_blank" rel="noopener">《我画了20张图给女朋友讲清楚红黑树》</a> - 程序员小吴</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;红黑树的基本结构&quot;&gt;&lt;a href=&quot;#红黑树的基本结构&quot; class=&quot;headerlink&quot; title=&quot;红黑树的基本结构&quot;&gt;&lt;/a&gt;红黑树的基本结构&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;&lt;strong&gt;红黑树(Red-black tree)&lt;/strong&gt; 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，常用于关联数组、字典等。C++ 中的标准关联容器set、multiset、map、multimap内部采用的数据结构就是红黑树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>SegmentTree</title>
    <link href="https://www.ccyh.xyz/p/bb82.html"/>
    <id>https://www.ccyh.xyz/p/bb82.html</id>
    <published>2020-01-29T16:41:27.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><hr><p>&emsp;线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。线段树可以在 $O(\log_{2}{N})$ 的时间复杂度内实现单点修改、区间修改、区间查询等操作。<br><a id="more"></a></p><h2 id="线段树的基本结构"><a href="#线段树的基本结构" class="headerlink" title="线段树的基本结构"></a>线段树的基本结构</h2><hr><p>为数组（假设下标从1开始）：<br>$$a[5] = [{1,2,3,4,5}]$$<br>构造线段树如下图（采用堆式存储）：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/SegmentTree/20200129054853716.png" alt="线段树示意"><br></center><p>上述数组 $D$ 用来保存线段树，由于采用的是堆式存储，因此$D[i]$ 的左右孩子结点分别为$D[2\times i],D[2 \times i + 1]$。不难发现上图有两种结点，银色结点括号表示该结点包含的数组 $a$ 的区间，$D[i]$ 的值表示 $\sum_{k=i}^{j}a[k]$。且若区间两端点相等为$[k,k]$则$D[i] = a[k]$即值为绿色结点。</p><h2 id="线段树的建立"><a href="#线段树的建立" class="headerlink" title="线段树的建立"></a>线段树的建立</h2><hr><p>由于树树递归定义的，因此其建立也是递归的：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; a)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(left == right)</span><br><span class="line">    &#123;</span><br><span class="line">        D[p] = a[left];</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;</span><br><span class="line">    build(left, mid, p*<span class="hljs-number">2</span>, D, a);</span><br><span class="line">    build(mid+<span class="hljs-number">1</span>, right, p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, D, a);</span><br><span class="line">    D[p] = D[p * <span class="hljs-number">2</span>] + D[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h2><hr><h3 id="区间和："><a href="#区间和：" class="headerlink" title="区间和："></a>区间和：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// [left,right]为待查区间，[cl,cr]为当前区间，p 为当前节点编号，D 为线段树的存储数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> cl, <span class="hljs-keyword">int</span> cr, <span class="hljs-keyword">int</span> p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;D)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt;= cl &amp;&amp; cr &lt;= right) <span class="hljs-comment">// 当前区间为待查区间的子集</span></span><br><span class="line"><span class="hljs-keyword">return</span> D[p];</span><br><span class="line">        <span class="hljs-comment">// 划分区间，递归查询</span></span><br><span class="line"><span class="hljs-keyword">int</span> mid = cl + (cr - cl)/<span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt;= mid) <span class="hljs-comment">// 与左区间有交集</span></span><br><span class="line">sum += getSum(left, right, cl, mid, p * <span class="hljs-number">2</span>, D);</span><br><span class="line"><span class="hljs-keyword">if</span>(right &gt; mid) <span class="hljs-comment">// 与右区间有交集</span></span><br><span class="line">sum += getSum(left, right, mid+<span class="hljs-number">1</span>, cr, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, D);</span><br><span class="line"><span class="hljs-keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h3><hr><p>$[cl,cr]$为当前区间，index为要修改的数组$a$的下标，$val$为修改的最终值，$p$为当前节点编号。<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cl, <span class="hljs-keyword">int</span> cr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(cl == cr)</span><br><span class="line">&#123;</span><br><span class="line">a[index] = val;</span><br><span class="line">D[p] = val;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> mid = cl + (cr - cl)/<span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(index &gt;= cl &amp;&amp; index &lt;= mid)</span><br><span class="line">updateST(cl, mid, index, val, p * <span class="hljs-number">2</span>, D, a);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &gt; mid &amp;&amp; index &lt;= cr)</span><br><span class="line">updateST(mid + <span class="hljs-number">1</span>, cr, index, val, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, D, a);</span><br><span class="line">D[p] = D[p * <span class="hljs-number">2</span>] + D[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时如果将$a[1]$ 改成 $6$ ,则树变成(红色表示有修改的节点)：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/SegmentTree/20200129082526967.png" alt="更新后的树"><br></center><hr><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; D(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a(<span class="hljs-number">6</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size();i++)</span><br><span class="line">a[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Building STree:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">buildST(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, D, a);</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"STree:"</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; D.size();i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; D[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Quary:(1,3)"</span>&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; getSum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,D) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Update: a[1] = 6"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">updateST(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,D,a);</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"STree:"</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; D.size();i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; D[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Quary:(1,3)"</span>&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; getSum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,D) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/SegmentTree/20200129084206509.png" alt="Result"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线段树&quot;&gt;&lt;a href=&quot;#线段树&quot; class=&quot;headerlink&quot; title=&quot;线段树&quot;&gt;&lt;/a&gt;线段树&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。线段树可以在 $O(\log_{2}{N})$ 的时间复杂度内实现单点修改、区间修改、区间查询等操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>DisjointSet</title>
    <link href="https://www.ccyh.xyz/p/65db.html"/>
    <id>https://www.ccyh.xyz/p/65db.html</id>
    <published>2020-01-29T14:07:30.000Z</published>
    <updated>2020-05-06T09:06:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一文读懂并查集"><a href="#一文读懂并查集" class="headerlink" title="一文读懂并查集"></a>一文读懂并查集</h2><hr><p>&emsp;假设你现在置身于一个鸡尾酒会中，任何人都不能通过直接搭讪来获得陌生漂亮妹子的微信号。于是你委托你的朋友帮忙，你的朋友委托他的朋友。。。直到找到一位与漂亮妹子认识的人拿到了微信号。因此，你通过这些中间朋友与妹子取得了联系，成功进入了她的社交圈。当然，你可以通过她认识跟多的漂亮妹子，走上人生巅峰。</p><a id="more"></a><p>&emsp;但是设想一下这样一个悲剧，那位漂亮妹子刚来到地球，她与地球上所有的人类都没有联系，那么你就无法通过中间人去认识她。你与她属于两个互不相交的社交圈。<br>&emsp;现在，不妨稍稍抽象一下，将酒会比作一个个人（元素）组成的集合，而集合中人与人间的关系比作元素与元素间的关系。那么，想要探讨两个人（元素）间是否能取得联系，只要看两者是否属于同一社交圈中，即是否有联系。<br>&emsp;而 <strong>并查集</strong> 的作用就是依赖这些元素两两间的联系来将这些元素区分为各个不相交的集合（社交圈），这样就可以判断两个元素是否直接或间接有联系。</p><hr><h2 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h2><hr><p>&emsp;现在我们假设酒会中有 6 个编号从 0 到 5 的人，并且他们两两之间的联系{(0,1),(1,2),(1,3),(4,5)}; 因此他们之间的关系网络如下图：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/relation.PNG" alt=""><br><br></center><p>&emsp;由于图中的边都是双向的，为了编程方便，不妨为各个连通分量分别指定一个根结点成为一棵棵树。如此一来要想判断两个结点之间是否有联系只需判断他们是否有相同的根节点即可（属于同一棵树）。由此关系网络转化为一个森林，森林中的每一棵树都是一个集合：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/relationtree.PNG" alt=""><br><br></center><p>&emsp;为了方便找出每一个结点的父结点，我们采用 <strong>树的双亲存储结构</strong> 来存储森林，如下图（ParentOf 数组）：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/parantandchild.PNG" alt="ParentOf 数组"><br><br></center><p>到此为止，已经了解了并查集是什么。接下来就是并查集的实现了。</p><hr><h2 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h2><hr><h3 id="求节点所在集合的根节点："><a href="#求节点所在集合的根节点：" class="headerlink" title="求节点所在集合的根节点："></a>求节点所在集合的根节点：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x_root = x;</span><br><span class="line"><span class="hljs-keyword">while</span>(parent[x_root] != x_root)</span><br><span class="line">&#123;</span><br><span class="line">x_root = parent[x_root];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> x_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并操作（根据两俩关系建立森林（parent数组））："><a href="#并操作（根据两俩关系建立森林（parent数组））：" class="headerlink" title="并操作（根据两俩关系建立森林（parent数组））："></a>并操作（根据两俩关系建立森林（parent数组））：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">union_verts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; rank)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 寻根</span></span><br><span class="line"><span class="hljs-keyword">int</span> x_root = get_root(x,parent);</span><br><span class="line"><span class="hljs-keyword">int</span> y_root = get_root(y,parent);</span><br><span class="line"><span class="hljs-keyword">if</span>(x_root != y_root)    <span class="hljs-comment">// 若不属于同一个集合</span></span><br><span class="line">&#123;</span><br><span class="line">parent[y_root] = x_root;    <span class="hljs-comment">// 并操作</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                   <span class="hljs-comment">// 合并成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查操作："><a href="#查操作：" class="headerlink" title="查操作："></a>查操作：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">quary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x_root = get_root(x, parent);</span><br><span class="line">    <span class="hljs-keyword">int</span> y_root = get_root(y, parent);</span><br><span class="line">    <span class="hljs-keyword">if</span>(x_root == y_root)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// x 与 y 有联系</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           <span class="hljs-comment">// x 与 y 无联系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="缺陷及其优化"><a href="#缺陷及其优化" class="headerlink" title="缺陷及其优化"></a>缺陷及其优化</h2><hr><p>&emsp;上述算法完全可以实现并查集，但是由于上述算法的并操作只是简单第将两棵树合并而不考虑两树的高度，这在某些极端情况下生成的树的高度会非常大（如下图）。而并查集操作的时间复杂度取决于树高，因此该算法的时间复杂度将会从 $O(\log_{2}{N})$ 退化成为 $O(N)$。</p><p>&emsp;因此，在合并两棵树的操作时我们要判断是将哪一棵树的根节点作为新树的根节点才能保证新树的高度尽可能小。举例如下图：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/Mergetree.PNG" alt=""><br><br></center><p>显然，存在两种情况：</p><ul><li><p>情况 1：新树树高为 4</p></li><li><p>情况 2：新树树高为 3</p><p>毫无疑问，应该按情况 2 来合并。</p></li></ul><h4 id="在并操作中作相应修改（路径压缩）："><a href="#在并操作中作相应修改（路径压缩）：" class="headerlink" title="在并操作中作相应修改（路径压缩）："></a>在并操作中作相应修改（路径压缩）：</h4><p>总结所有的情况：</p><ul><li>两树等高：随便合并</li><li>两树不等高：将较矮的树并到较高的树中</li></ul><p>因此，我们需要记录以某节点为根的子树的高度，存储在rank数组中。rank[i] 表示以 i 节点为根的子树的高度。</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">union_verts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; rank)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x_root = get_root(x,parent);</span><br><span class="line"><span class="hljs-keyword">int</span> y_root = get_root(y,parent);</span><br><span class="line"><span class="hljs-keyword">if</span>(x_root != y_root)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-comment">// 不等高</span></span><br><span class="line"><span class="hljs-keyword">if</span>(rank[x_root] &gt; rank[y_root])</span><br><span class="line">&#123;</span><br><span class="line">parent[y_root] = x_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[x_root] &lt; rank[y_root])</span><br><span class="line">&#123;</span><br><span class="line">parent[x_root] = y_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span><span class="hljs-comment">// 等高</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x_root] = y_root;</span><br><span class="line">rank[y_root]++;<span class="hljs-comment">// 改变树高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，就有效避免了树的狂长。</p><hr><h2 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent(<span class="hljs-number">6</span>);</span><br><span class="line">    <span class="hljs-comment">// 初始化parent数组</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; parent.size();i++) parent[i] = i;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rank(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; edges = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;</span><br><span class="line">    <span class="hljs-comment">// 建立并查集</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; edges.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = edges[i][<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> y = edges[i][<span class="hljs-number">1</span>];</span><br><span class="line">        union_verts(x,y,parent,rank)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 查看 1 与 5 , 2 与 3 是否有联系（同属一个集合）</span></span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Boy 1 and Girl 5 will fall in love: "</span> &lt;&lt; quary(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/Matchresult.PNG" alt=""><br><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一文读懂并查集&quot;&gt;&lt;a href=&quot;#一文读懂并查集&quot; class=&quot;headerlink&quot; title=&quot;一文读懂并查集&quot;&gt;&lt;/a&gt;一文读懂并查集&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;假设你现在置身于一个鸡尾酒会中，任何人都不能通过直接搭讪来获得陌生漂亮妹子的微信号。于是你委托你的朋友帮忙，你的朋友委托他的朋友。。。直到找到一位与漂亮妹子认识的人拿到了微信号。因此，你通过这些中间朋友与妹子取得了联系，成功进入了她的社交圈。当然，你可以通过她认识跟多的漂亮妹子，走上人生巅峰。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://www.ccyh.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="https://www.ccyh.xyz/p/ac7c.html"/>
    <id>https://www.ccyh.xyz/p/ac7c.html</id>
    <published>2020-01-29T14:04:49.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><hr><p>&emsp;据不完全统计，世界上现存英语单词的数量为17万到100万不等。假设现在要你写一个词典APP，要求能够快速检索、删除、添加单词，。显然你很容易想到两种方案：</p><ol><li>将所有单词按字典序排列，在按二分搜索来查询。</li><li>奖励首字母索引表，在各索引项表内按字典序排序单词，再在当中按二分搜索查询。<br>但无疑上述方案的要求略高，需要大量的连续空间来存储数据，而且不方便添加删除操作。</li></ol><a id="more"></a><p>&emsp;这时Trie树便发挥作用了，我们可以用Trie树来存储单词数据，树结构不需要大量连续的存储空间而且查询、添加结点、删除结点的操作的时间复杂度很小为$O(\log_{2}{N})$。</p><h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><p>&emsp;假设存储<br>$$[{“code”,”cook”,”five”,”file”,”fat”}]$$<br>&emsp;这几个单词。其逻辑结构为：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%AD%97%E5%85%B8%E6%A0%91/20200129024314865.png" alt=""><br></center><h2 id="Trie树的实现"><a href="#Trie树的实现" class="headerlink" title="Trie树的实现"></a>Trie树的实现</h2><hr><h3 id="结点结构："><a href="#结点结构：" class="headerlink" title="结点结构："></a>结点结构：</h3><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%AD%97%E5%85%B8%E6%A0%91/20200129030049923.png" alt="结点结构"><br></center><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">char</span> nodeChar;<span class="hljs-comment">// 该结点表示的字符</span></span><br><span class="line">    <span class="hljs-keyword">int</span> freq;<span class="hljs-comment">// 出现的频率</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> isWord; <span class="hljs-comment">// 单词结点结束标记</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;TrieNode*&gt; childNode;<span class="hljs-comment">// 先一个结点的指针</span></span><br><span class="line">    TrieNode()<span class="hljs-comment">// 初始化结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        freq = <span class="hljs-number">0</span>;</span><br><span class="line">        isWord = <span class="hljs-literal">false</span>;</span><br><span class="line">        childNode = <span class="hljs-built_in">vector</span>&lt;TrieNode*&gt;(<span class="hljs-number">26</span>,<span class="hljs-literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="树的大致结构："><a href="#树的大致结构：" class="headerlink" title="树的大致结构："></a>树的大致结构：</h4><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%AD%97%E5%85%B8%E6%A0%91/20200129030856288.png" alt="树的结构"><br></center><ul><li>根节点的nodeChar不存储字符， 其字符表示位于指针数组中，指针数组的某元素不空则表示存在以其为首字符的单词。</li></ul><hr><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 添加操作</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(TrieNode* root, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> k)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(k &gt;= word.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 将word的首字母插入到root的哪一个分叉中</span></span><br><span class="line">    <span class="hljs-keyword">int</span> index = word[k] - <span class="hljs-string">'a'</span>;</span><br><span class="line">    <span class="hljs-comment">// 若该树为空，插入新结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(root-&gt;childNode[index] == <span class="hljs-literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;childNode[index] = <span class="hljs-keyword">new</span> TrieNode();</span><br><span class="line">        root-&gt;childNode[index]-&gt;nodeChar = word[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span>(k == word.size()<span class="hljs-number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-comment">// 终端结点标记</span></span><br><span class="line">            root-&gt;childNode[index]-&gt;isWord = <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addWord(root-&gt;childNode[index], word, k+<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(k == word.size()<span class="hljs-number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;childNode[index]-&gt;isWord = <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 递归添加结点</span></span><br><span class="line">        addWord(root-&gt;childNode[index], word, k+<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 查询操作</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchWord</span><span class="hljs-params">(TrieNode* root, <span class="hljs-built_in">string</span> word)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    TrieNode* p = root;</span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; word.size() &amp;&amp; p != <span class="hljs-literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> index = word[i] - <span class="hljs-string">'a'</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(p-&gt;childNode[index] == <span class="hljs-literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(i == word.size()<span class="hljs-number">-1</span>)</span><br><span class="line">                p-&gt;childNode[index]-&gt;freq++;</span><br><span class="line">            p = p-&gt;childNode[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(i == word.size() &amp;&amp; p-&gt;isWord)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><hr><p>删除操作比较复杂，分三种情况：</p><pre><code>1. 删除整个单词 （该单词的尾结点为叶子节点，且该单词独占一条路径）2. 删除前缀词 （该单词的尾结点非叶子节点）3. 删除分支单词 （该单词的尾结点为叶子节点但存在于其他单词共用的路径）</code></pre><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeave</span><span class="hljs-params">(TrieNode* node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(node-&gt;childNode[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteWord</span><span class="hljs-params">(TrieNode* root, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> k)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(k &gt;= word.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete into "</span> &lt;&lt; word[k] &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> index = word[k] - <span class="hljs-string">'a'</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span>(root-&gt;childNode[index] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'d'</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        deleteWord(root-&gt;childNode[index], word, k+<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span>(isLeave(root) &amp;&amp; !root-&gt;isWord)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dc"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">            <span class="hljs-keyword">delete</span> root;</span><br><span class="line">            root = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == word.size()<span class="hljs-number">-1</span> &amp;&amp; !isLeave(root))</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;isWord = <span class="hljs-literal">false</span>;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dd"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteKey</span><span class="hljs-params">(TrieNode *root, <span class="hljs-built_in">string</span> word)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(searchWord(root, word))</span><br><span class="line">    &#123;</span><br><span class="line">        deleteWord(root, word, <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title=&quot;Trie树&quot;&gt;&lt;/a&gt;Trie树&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;据不完全统计，世界上现存英语单词的数量为17万到100万不等。假设现在要你写一个词典APP，要求能够快速检索、删除、添加单词，。显然你很容易想到两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将所有单词按字典序排列，在按二分搜索来查询。&lt;/li&gt;
&lt;li&gt;奖励首字母索引表，在各索引项表内按字典序排序单词，再在当中按二分搜索查询。&lt;br&gt;但无疑上述方案的要求略高，需要大量的连续空间来存储数据，而且不方便添加删除操作。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>二分图最大匹配问题(匈牙利算法)</title>
    <link href="https://www.ccyh.xyz/p/5e12.html"/>
    <id>https://www.ccyh.xyz/p/5e12.html</id>
    <published>2019-11-25T20:33:10.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>&emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 <strong>奇环</strong> (边为奇数的环路)， 如果一个图没有 <strong>奇环</strong> ,那么它就一定是 二分图。</p><a id="more"></a><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/bm.PNG#pic_center" alt="二分图"><br></center><h2 id="二分图的匹配"><a href="#二分图的匹配" class="headerlink" title="二分图的匹配"></a>二分图的匹配</h2><p>&emsp;给定一个二分图 G , 在 G 的一个子图 M 中， M 的边集 { E } 中的任意两条边都不依附于同一个顶点， 则称 M 是一个匹配。 翻译成人话就是 在图 G 中找到一些边构成一个集合， 这个集合中的任意一条边所连接的两个顶点都只属于这条边的连个端点，即每条边的顶点都不与其他边共用。如下图： 边集合 E = {(1,5),(3,6),(4,7)} 构成了一个匹配。</p><center><br> <img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/match.PNG#pic_center" alt="匹配"><br></center><h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><p> &emsp;顾名思义，就是最大化满足上述规定的边集 E 。如上图的一个最大匹配结果为：</p><center><br> <img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/maxmatch.PNG#pic_center" alt="最大匹配"><br></center><hr><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>&emsp;此算法由美国数学家 <strong>哈罗德·库恩</strong> 于1955年提出该算法。先介绍两个概念：<br>&emsp;<strong>交替路</strong>： 从一个未匹配顶点出发，依次经过非匹配边、匹配边、非匹配边 … 形成的路径叫作 交替路。<br>&emsp;<strong>增广路</strong>： 从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路就称为增广路(agumenting path)，且增广路中非匹配边的数目要大于匹配边的数目。 如下图：图中已匹配点带蓝色标记，红色箭头边为一条匹配边，黑色箭头边为非匹配边。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/m.PNG#pic_center" alt=""><br></center><p>&emsp;展开来就是这样的一条 <strong>增广路</strong>：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/road.PNG#pic_center" alt=""><br></center><p>&emsp;如果此时将上述增广路的 匹配边与非匹配边<strong>对调</strong> ：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/nroad.PNG#pic_center" alt=""><br></center><p>&emsp;不难发现，匹配边多了一条（两条变三条），并且新增了两个匹配顶点。如此一来，边集 E 内不就多了一条边吗，符合我们的目标（最大化边集 E）。因此，匈牙利算法的 <strong>核心</strong> 就是 <strong>不断地寻找增广路径</strong> ，以便可以不断扩大边集 E，得到一个更大的匹配。</p><p><strong>总结增广路的定义：</strong></p><ul><li>其路径长度必定为奇数，且第一条边与最后一条边必定都不属于 M（最大匹配子图）。</li><li>该路径经过取反操作（匹配变不匹配，不匹配变匹配）后可以得到一个更大的匹配 M’。</li><li>M 为 G 的最大匹配当且仅当不存在相对于 M 的增广路径。</li></ul><hr><h3 id="算法概述："><a href="#算法概述：" class="headerlink" title="算法概述："></a>算法概述：</h3><ol><li>从 X 集合中选一个未匹配点 u 作为起点。选一条非匹配边(u,v), 到 Y中的点 v。</li><li>如果 v 是为匹配点， 说明找到了一条增广路。</li><li>否则若 v 是匹配点，下一步走匹配边，v 恰好和一条匹配边邻接。 设另一端为 left[v], 可以理解为 u 直接走到了 left[v], 也是 X 中的点。<ul><li>如果始终没有找到未匹配点（找不到最后一条非匹配边）,最后会扩展出一棵匈牙利树（root 是未匹配点， 叶子节点都是匹配点），从 root 到 leaf 的路径都不是增广路。</li></ul></li><li>每次选择一个未匹配点 u 进行 DFS。 如果找不到以 u 开头的增广路，就换一个未匹配点来进行 DFS， 且以后再也不从 u 出发找增广路了。<ul><li>如果以后存在一个从 u 出发的增广路，那么现在肯定找得到。</li></ul></li></ol><hr><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 0x00ff</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPM</span> &#123;</span>  <span class="hljs-comment">// 二分图的最大奇数匹配</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, e; <span class="hljs-comment">// 左右顶点个数, 边数</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; G;      <span class="hljs-comment">// G[x][y] == 1,表示存在边 x - y</span></span><br><span class="line"><span class="hljs-keyword">int</span> *left;    <span class="hljs-comment">// left[i] 为右边（Y 集合）第i个顶点的匹配顶点编号</span></span><br><span class="line"><span class="hljs-keyword">bool</span> *T;  <span class="hljs-comment">// T[i] = true 表示第i个顶点已经被标记已访问</span></span><br><span class="line"></span><br><span class="line">BPM() </span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; e;</span><br><span class="line">T = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[maxn];</span><br><span class="line">left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxn];</span><br><span class="line">G = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(maxn,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(maxn,<span class="hljs-literal">false</span>));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> t1, t2;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">G[t1][t2] = <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">memset</span>(T, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(T));</span><br><span class="line"><span class="hljs-built_in">memset</span>(left, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> <span class="hljs-comment">// 匈牙利算法</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; m ; v++) <span class="hljs-comment">// 遍历右边 Y 集合中的顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(G[u][v] &amp;&amp; !T[v])</span><br><span class="line">&#123;</span><br><span class="line">T[v] = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(left[v] == <span class="hljs-number">-1</span> || match(left[v]))<span class="hljs-comment">// left[v] != -1, left[v] 是 v 的匹配边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">// 若 v 未匹配就将它与 u 匹配(相当于找到了一条增广路 u -&gt; v)，否则通过 v 的匹配点继续找未匹配点</span></span><br><span class="line">left[v] = u;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> <span class="hljs-comment">// 求最大匹配</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 匹配数</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; n; u++) <span class="hljs-comment">// 遍历左边顶点寻找增广路</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">memset</span>(T, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(T));</span><br><span class="line"><span class="hljs-keyword">if</span>(match(u))</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"--"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">ans++; <span class="hljs-comment">// 找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二分图&quot;&gt;&lt;a href=&quot;#二分图&quot; class=&quot;headerlink&quot; title=&quot;二分图&quot;&gt;&lt;/a&gt;二分图&lt;/h2&gt;&lt;p&gt;&amp;emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 &lt;strong&gt;奇环&lt;/strong&gt; (边为奇数的环路)， 如果一个图没有 &lt;strong&gt;奇环&lt;/strong&gt; ,那么它就一定是 二分图。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Graph" scheme="https://www.ccyh.xyz/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>【图解算法】Tarjan算法求图的强连通分量</title>
    <link href="https://www.ccyh.xyz/p/75c4.html"/>
    <id>https://www.ccyh.xyz/p/75c4.html</id>
    <published>2019-11-21T21:58:23.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强连通分量简介"><a href="#强连通分量简介" class="headerlink" title="强连通分量简介"></a>强连通分量简介</h2><p>&emsp;&emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p><a id="more"></a><p>&emsp;&emsp;比如下图：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/%E8%BF%9E%E9%80%9A%E5%9B%BE.PNG#pic_center" alt=""><br></center><hr><h2 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a>Tarjan 算法</h2><p>&emsp;Tarjan算法是用来求强连通分量的，它是一种基于DFS（深度优先搜索）的算法，每个强连通分量为搜索树中的一棵子树。并且运用了数据结构栈。由于栈的先进先出的性质可以保证当前在栈中的结点中先入栈的结点必然有一条通路通往后入栈的结点，这样一来判断后入栈的结点是否有一条路径通向先入栈结点就成了算法要解决的主要问题。<br><strong>算法思路：</strong><br>&emsp;首先引入两个数组 dfn[maxn] 和 low[maxn], 其中 dfn[i] 表示编号为 i 的节点被访问时的时间戳；low[i] 表示从编号为 i 的节点可追溯到（到达）的最早被访问到的节点的时间戳。下面通过上述例子跑一遍算法，描绘出每个时刻的DFS树状态和栈中的内容。</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/1.PNG#pic_center" alt="第一步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/2.PNG#pic_center" alt="第二步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/3.PNG#pic_center" alt="第三步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/4.PNG#pic_center" alt="第四步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/5.PNG#pic_center" alt="第五步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/6.PNG#pic_center" alt="第六步"><br><br></center><p>&emsp;由上述过程可得该图由三个连通分量：{5}，{4}，{2,3,1,0}</p><hr><h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><blockquote><p>代码中有详细注释，可结合上述图例分析</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*  求强连通分量： Tarjan算法</span></span><br><span class="line"><span class="hljs-comment">    Tarjan 算法， 以Robert Tarjan的名字命名的算法</span></span><br><span class="line"><span class="hljs-comment">    该算法用来在线性时间内求解图的连通性问题</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ssc</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;</span><br><span class="line">    Ssc(<span class="hljs-keyword">int</span> n_, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;g) : n(n_) &#123;         <span class="hljs-comment">// InitializeMG</span></span><br><span class="line">        graph = g;</span><br><span class="line">        dfn = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);</span><br><span class="line">        low = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);</span><br><span class="line">        scc = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n,<span class="hljs-literal">false</span>);</span><br><span class="line">        time = <span class="hljs-number">0</span>;</span><br><span class="line">        sscnum = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;   Sscs;     <span class="hljs-comment">// 所有连通分量</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;  graph;     <span class="hljs-comment">// 有向图的邻接矩阵</span></span><br><span class="line">    <span class="hljs-keyword">int</span>                      n;     <span class="hljs-comment">// 顶点总数</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;  dfn;               <span class="hljs-comment">// 时间戳数组</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;  low;               <span class="hljs-comment">// 最小时间戳数组（能够追溯到的最早栈中节点时间戳）</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; scc;               <span class="hljs-comment">// 在栈内标记数组</span></span><br><span class="line">    <span class="hljs-keyword">int</span>         time,               <span class="hljs-comment">// 时间</span></span><br><span class="line">              sscnum;               <span class="hljs-comment">// 连通分量数</span></span><br><span class="line">    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;           stk;       <span class="hljs-comment">// 遍历栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> Ssc::Tarjan(<span class="hljs-keyword">int</span> root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>( dfn[root] ) <span class="hljs-keyword">return</span>;                     <span class="hljs-comment">// 访问过了，直接返回</span></span><br><span class="line">    dfn[root] = low[root] = ++time;</span><br><span class="line">    stk.push(root);                             <span class="hljs-comment">// 入栈</span></span><br><span class="line">    scc[root] = <span class="hljs-literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;v &lt; n;v++)                    <span class="hljs-comment">// 遍历 root 所指节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!dfn[v] &amp;&amp; graph[root][v])           <span class="hljs-comment">// v 还未被访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[root] = min(low[root], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scc[v] &amp;&amp; graph[root][v])       <span class="hljs-comment">// 如果 v 还在栈内</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[root] = min(low[root], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>(low[root] == dfn[root])                  <span class="hljs-comment">// 后代不能找到更浅的节点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        sscnum ++;                              <span class="hljs-comment">// 记数</span></span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sc;                         <span class="hljs-comment">// 保存当前连通分量</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)                             <span class="hljs-comment">// 依次退栈至 root</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> x = stk.top();</span><br><span class="line">            scc[x] = <span class="hljs-literal">false</span>;</span><br><span class="line">            stk.pop();</span><br><span class="line">            sc.push_back(x);</span><br><span class="line">            <span class="hljs-keyword">if</span>(x == root) <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Sscs.push_back(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="hljs-function">Ssc <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-number">6</span>, graph)</span></span>;</span><br><span class="line">    S.Tarjan(<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : S.Sscs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SSC ("</span> &lt;&lt; index++ &lt;&lt; <span class="hljs-string">") : "</span>; </span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The Number of SSC : "</span> &lt;&lt; S.sscnum &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/Tarjan.PNG#pic_center" alt="Result"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;强连通分量简介&quot;&gt;&lt;a href=&quot;#强连通分量简介&quot; class=&quot;headerlink&quot; title=&quot;强连通分量简介&quot;&gt;&lt;/a&gt;强连通分量简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&amp;gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其改进</title>
    <link href="https://www.ccyh.xyz/p/f367.html"/>
    <id>https://www.ccyh.xyz/p/f367.html</id>
    <published>2019-11-19T22:37:51.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><a id="more"></a><h2 id="简单快速排序算法"><a href="#简单快速排序算法" class="headerlink" title="简单快速排序算法"></a>简单快速排序算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">Partition</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = p, j = r+<span class="hljs-number">1</span>;</span><br><span class="line">Type x = a[p]; <span class="hljs-comment">// 确定主元</span></span><br><span class="line"><span class="hljs-comment">// 划分</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r); <span class="hljs-comment">// 从左往右寻找比 x 大的元素</span></span><br><span class="line"><span class="hljs-keyword">while</span>(a[--j] &gt; x);<span class="hljs-comment">// 从右往左寻找比 x 小的元素</span></span><br><span class="line"><span class="hljs-keyword">if</span>(i &gt;= j)</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">swap(a[i], a[j]);<span class="hljs-comment">// 交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[p] = a[j];<span class="hljs-comment">// j 最终停留在一个比 x 小的数上面</span></span><br><span class="line">a[j] = x;<span class="hljs-comment">// 将主元放到最终位置</span></span><br><span class="line"><span class="hljs-keyword">return</span> j;<span class="hljs-comment">// 返回枢轴元素下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p &lt; r)<span class="hljs-comment">// 递归出口，只有一个元素时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = Partition(a, p, r); <span class="hljs-comment">// 得到划分位置</span></span><br><span class="line">QuickSort(a, p, q<span class="hljs-number">-1</span>);<span class="hljs-comment">// 排序左子序列</span></span><br><span class="line">QuickSort(a, q+<span class="hljs-number">1</span>, r);<span class="hljs-comment">// 排序右子序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//-----------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><hr><p> 快速排序在平均情况下时间复杂度为 O(nlog n)<br> 最坏情况下(如待排序列有序)为 O(n^2)<br> 要使得在最坏情况下时间复杂度为 O(nlog n)<br> 容易看到，快速排序的性能取决于划分的 对称性<br> 可以每次都将问题划分为相等规模的两个子问题<br> 即 T(n) = 2T(n/2) + n<br> 由主定理解得 T(n) = O(nlog n)<br> 因此可以用一个算法选取当前序列的中位数将其作为主元(pivot)，将子问题划分为原问题的一半规模</p><h2 id="随机选择快速排序算法"><a href="#随机选择快速排序算法" class="headerlink" title="随机选择快速排序算法"></a>随机选择快速排序算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 随机选择快速排序算法在当数组还没有被划分时随机第从 a[p:r] 中选择主元作为划分基准</span></span><br><span class="line"><span class="hljs-comment">// 从而可以期望划分是较对称的</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (rand() % (r-p+<span class="hljs-number">1</span>))+ p;<span class="hljs-comment">// 生成 [p,r] 区间内的随机整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">RandomizedPartition</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = Random(p, r);<span class="hljs-comment">// 产生一个属于 [p:r] 区间的随机数</span></span><br><span class="line">swap(a[i], a[p]);</span><br><span class="line"><span class="hljs-keyword">return</span> Partition(a, p, r);<span class="hljs-comment">// 调用划分函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">RandomizedQuickSort</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = RandomizedPartition(a, p, r);<span class="hljs-comment">// 随机划分</span></span><br><span class="line">RandomizedQuickSort(a, p, q<span class="hljs-number">-1</span>);<span class="hljs-comment">// 排序左子序列</span></span><br><span class="line">RandomizedQuickSort(a, q+<span class="hljs-number">1</span>, r);<span class="hljs-comment">// 排序右子序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机线性时间选择算法"><a href="#随机线性时间选择算法" class="headerlink" title="随机线性时间选择算法"></a>随机线性时间选择算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 由于RandomizedSelect中使用了RandomizedPartition产生的划分基准是随机的</span></span><br><span class="line"><span class="hljs-comment">// 在这个条件下可以证明，算法RandomizedSelect可以在 O(n) 的平均时间内找出n个输入的第 k 小元素</span></span><br><span class="line"><span class="hljs-comment">// 但其在最坏情况下的时间复杂度为 O(n^2),比如在找最小元素时(k=1),总是在最大元素处划分</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"> <span class="hljs-title">Type</span> <span class="hljs-title">RandomizedSelect</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>, <span class="hljs-title">int</span> <span class="hljs-title">k</span>)   // 返回第 <span class="hljs-title">k</span> 小的数</span></span><br><span class="line"><span class="hljs-class"> &#123;</span></span><br><span class="line"> <span class="hljs-keyword">if</span>(p == r)</span><br><span class="line"> <span class="hljs-keyword">return</span> a[p];</span><br><span class="line"> <span class="hljs-keyword">int</span> i = RandomizedPartition(a, p, r);<span class="hljs-comment">// 随机划分</span></span><br><span class="line"> <span class="hljs-keyword">int</span> j = i - p + <span class="hljs-number">1</span>;<span class="hljs-comment">// 计算前半部分子序列长度</span></span><br><span class="line"> <span class="hljs-keyword">if</span>(k &lt;= j)<span class="hljs-comment">// 如果 j &gt;= k ,说明第 k 小的元素在前半部分</span></span><br><span class="line"> <span class="hljs-keyword">return</span> RandomizedSelect(a, p, i, k);</span><br><span class="line"> <span class="hljs-keyword">else</span><span class="hljs-comment">// 否则, 第 k 小的元素在右半部分</span></span><br><span class="line"> <span class="hljs-keyword">return</span> RandomizedSelect(a, i+<span class="hljs-number">1</span>, r, k-j);<span class="hljs-comment">// 从右半部分中寻找第 k - j 小的元素</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="线性时间选择算法"><a href="#线性时间选择算法" class="headerlink" title="线性时间选择算法"></a>线性时间选择算法</h2><p>下面讨论一个最坏情况下可以在 O(n) 时间内找到第 k 小的元素的线性时间选择算法<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// </span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment"> *1. 将 n 个元素划分成 n/5 个分组， 每组 5 个元素， 除可能有一个组不是 5 个元素外。用任意一种排序算法，</span></span><br><span class="line"><span class="hljs-comment"> *   将每组中的元素排好序，并去除每组的中位数，共 n/5 个。</span></span><br><span class="line"><span class="hljs-comment"> *2. 递归调用 Select 函数找出这 n/5 个元素的中位数。 如果 n/5 为偶数，就找他的两个中位数中较大的一个</span></span><br><span class="line"><span class="hljs-comment"> *   然后以这个元素作为划分基准。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],  <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span><span class="hljs-comment">// 插入排序</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = p+<span class="hljs-number">1</span>; i &lt;= r; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j + <span class="hljs-number">1</span>] &lt; a[j]; j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j], a[j + <span class="hljs-number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">Type</span> <span class="hljs-title">Select</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>, <span class="hljs-title">int</span> <span class="hljs-title">k</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(r - p &lt; <span class="hljs-number">75</span>)</span><br><span class="line">&#123;</span><br><span class="line">insertSort(a,p,r);<span class="hljs-comment">// 简单插入排序</span></span><br><span class="line"><span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<span class="hljs-comment">// 返回中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">// 将 a[p + 5 * i] 至 a[p + 5 * i + 4] 的第三小元素与 a[p + i] 交换位置</span></span><br><span class="line">Type x = Select(a, p, p + (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<span class="hljs-comment">// 找出中位数中的中位数，r-p-4 即为 n-5</span></span><br><span class="line"><span class="hljs-keyword">int</span> m = Partition(a, p, r, x) , j = i - p + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(k &lt;= j)</span><br><span class="line"><span class="hljs-keyword">return</span> Select(a, p, m, k);</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">return</span> Select(a, m+<span class="hljs-number">1</span>, r, k-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三路划分快速排序"><a href="#三路划分快速排序" class="headerlink" title="三路划分快速排序"></a>三路划分快速排序</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">QuickSort3Way</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">left</span>, <span class="hljs-title">int</span> <span class="hljs-title">right</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">Type x = a[right];<span class="hljs-comment">// 取尾元素为主元(基准)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// i 指向序列头元素的前一个元素(不存在)</span></span><br><span class="line"><span class="hljs-comment">// j 指向序列尾元素</span></span><br><span class="line"><span class="hljs-comment">// p 与 i 相同</span></span><br><span class="line"><span class="hljs-comment">// q 与 j 相同</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>, j = right, p = left - <span class="hljs-number">1</span>, q = right;</span><br><span class="line"><span class="hljs-comment">// 开始划分</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>( a[++i] &lt; x );<span class="hljs-comment">// 从左往右找大于x的元素</span></span><br><span class="line"><span class="hljs-keyword">while</span>( a[--j] &gt; x ) <span class="hljs-keyword">if</span>( j == left ) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 从右往左找小于x的元素</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(i &lt; j)<span class="hljs-comment">// i j 未交错</span></span><br><span class="line">&#123;</span><br><span class="line">swap(a[i], a[j]);<span class="hljs-comment">// 交换</span></span><br><span class="line"><span class="hljs-keyword">if</span>(a[i] == x) &#123; p++; swap( a[p], a[i] ); &#125;<span class="hljs-comment">// 将与主元相等的元素交换到两侧</span></span><br><span class="line"><span class="hljs-keyword">if</span>(a[j] == x) &#123; q--; swap( a[q], a[j] ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">// i j 交错， i 为主元最终位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(a[i], a[right]);<span class="hljs-comment">// 将主元交换到最终位置</span></span><br><span class="line">j = i - <span class="hljs-number">1</span>;</span><br><span class="line">i = i + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-comment">// 此时 p，q 指向两侧与主元相等元素的最内侧元素</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">如下图：x 为主元</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">x x x x x x x a d d t g e w x d i s e s x x x x</span></span><br><span class="line"><span class="hljs-comment">            |             |   |         |</span></span><br><span class="line"><span class="hljs-comment">            p             j   i         q</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = left;  k &lt;= p; k++, j--) swap( a[k], a[j] );<span class="hljs-comment">// 将左侧相等元素交换到主元左边</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = right - <span class="hljs-number">1</span>; k &gt;= q; k--, i++) swap( a[i], a[k] );<span class="hljs-comment">// 将右侧相等元素交换到主元右边</span></span><br><span class="line"><span class="hljs-comment">// 一次划分结束</span></span><br><span class="line"></span><br><span class="line">QuickSort3Way(a, left,  j);</span><br><span class="line">QuickSort3Way(a, i, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">28</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">65</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">63</span>,<span class="hljs-number">78</span>,<span class="hljs-number">23</span>,<span class="hljs-number">61</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>&#125;;</span><br><span class="line"><span class="hljs-comment">//RandomizedQuickSort(a,0,19);</span></span><br><span class="line"><span class="hljs-keyword">time_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">QuickSort3Way(a, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>);</span><br><span class="line">end   = clock();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">1.0</span> * (end - start)/CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">" s "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">20</span>;i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="QuickSort" scheme="https://www.ccyh.xyz/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>侯捷C++学习笔记[未整理版]</title>
    <link href="https://www.ccyh.xyz/p/6c8e.html"/>
    <id>https://www.ccyh.xyz/p/6c8e.html</id>
    <published>2019-11-13T22:13:59.000Z</published>
    <updated>2020-05-06T09:06:17.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还没有整理过的笔记，有点乱</p></blockquote><a id="more"></a><h1 id="C-程序设计II-兼谈对象模型"><a href="#C-程序设计II-兼谈对象模型" class="headerlink" title="C++ 程序设计II 兼谈对象模型"></a>C++ 程序设计II 兼谈对象模型</h1><hr><h2 id="Conversion-function-转换函数-operator-type"><a href="#Conversion-function-转换函数-operator-type" class="headerlink" title="Conversion function - 转换函数 operator type()"></a>Conversion function - 转换函数 operator type()</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// this type -&gt; other type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类，分数可以被看成double</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    Fraction(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den = <span class="hljs-number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 最好加const </span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="hljs-comment">// 转换函数，不唯一，合理就行</span></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    <span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// 调用 operator double() 将 f 转换成 double</span></span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 4.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other type -&gt; this type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">// non-explicit-one-argument constructor</span></span><br><span class="line">    Fraction(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den = <span class="hljs-number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/* 当下面operator type() 函数同时存在时，会迷惑编译器，出错 ambiguous</span></span><br><span class="line"><span class="hljs-comment">    // 因为有两条路可行：</span></span><br><span class="line"><span class="hljs-comment">        1. 将 4 转Fraction</span></span><br><span class="line"><span class="hljs-comment">        2. 将 f 转double 在将 4.6 转Fraction</span></span><br><span class="line"><span class="hljs-comment">        从而产生歧义</span></span><br><span class="line"><span class="hljs-comment">    operator double() const // 最好加const </span></span><br><span class="line"><span class="hljs-comment">    &#123;</span></span><br><span class="line"><span class="hljs-comment">        return ((double)m_numerator / m_denominator);</span></span><br><span class="line"><span class="hljs-comment">    &#125; // 转换函数</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// 调用 non-explicit ctor 将 4 转换成 Fraction,然后调用operator+()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other type -&gt; this type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">// explicit-one-argument constructor</span></span><br><span class="line">    explicit Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) &#123;&#125; // 90% 的 explicit 用在构造函数上</span><br><span class="line">    Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 最好加const </span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="hljs-comment">// 转换函数</span></span><br><span class="line">    */</span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// [Error] conversion from double to Fraction requested, 4 不能自动转为Fraction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span>&lt;bool, Alloc&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">        <span class="hljs-keyword">typedef</span> __bit_reference reference;</span><br><span class="line">    <span class="hljs-keyword">protected</span>:</span><br><span class="line">        reference <span class="hljs-keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> *(begin() + defference_type(n));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>* p;</span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask;</span><br><span class="line">    ...</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> !(!(*p &amp; mask)); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pointer-like-classes-关于智能指针"><a href="#pointer-like-classes-关于智能指针" class="headerlink" title="pointer-like classes, 关于智能指针"></a>pointer-like classes, 关于智能指针</h2><hr><blockquote><blockquote><p>一个 class 产生出来的对象像一个指针(do more then pointer, such as auto pointer)</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">        <span class="hljs-comment">// 固定写法</span></span><br><span class="line">        T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *px;&#125;</span><br><span class="line">        T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> px;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">shared_ptr</span>(T* p) : px(px) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        T*    px; <span class="hljs-comment">// 指向 T 的指针</span></span><br><span class="line">        <span class="hljs-keyword">long</span>* pn;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; sp(<span class="hljs-keyword">new</span> Foo); <span class="hljs-comment">// 初始化sp为指向Foo的智能指针,即sp内部的px指向Foo</span></span><br><span class="line">    <span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(*sp)</span></span>; <span class="hljs-comment">// *p 调用 operator*()</span></span><br><span class="line">    sp -&gt; method(); <span class="hljs-comment">// 调用 method 函数 等价于 调用operator-&gt;() 再调用 px -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pointer-like-classes-关于迭代器-一种特别的智能指针"><a href="#pointer-like-classes-关于迭代器-一种特别的智能指针" class="headerlink" title="pointer-like classes, 关于迭代器(一种特别的智能指针)"></a>pointer-like classes, 关于迭代器(一种特别的智能指针)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// list 链表节点设计</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> __<span class="hljs-title">list_node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">void</span>* prev;</span><br><span class="line">    <span class="hljs-keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;lass T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ref</span>, <span class="hljs-title">class</span> <span class="hljs-title">Ptr</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> __<span class="hljs-title">list_iterator</span> &#123;</span> <span class="hljs-comment">// 链表的迭代器实现</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> __list_node&lt;T&gt;* link_type; <span class="hljs-comment">// 指向链表节点的指针类型</span></span><br><span class="line">    link_type node; <span class="hljs-comment">// node 为指向链表节点的指针</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> self&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> self&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> node != x.node;&#125;</span><br><span class="line">    <span class="hljs-comment">// 本节重点</span></span><br><span class="line">    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="hljs-keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//前置</span></span><br><span class="line">    self <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;self tmp = *<span class="hljs-keyword">this</span>; ++*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//后置</span></span><br><span class="line">    self&amp; <span class="hljs-keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//前置</span></span><br><span class="line">    self <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>) &#123;self tmp = *<span class="hljs-keyword">this</span>; --*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//后置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">list</span>&lt;Foo&gt;::iterator it;</span><br><span class="line">    *it; <span class="hljs-comment">// 获得一个Foo对象</span></span><br><span class="line">    it -&gt; method();</span><br><span class="line">    <span class="hljs-comment">// 调用Foo::method()</span></span><br><span class="line">    <span class="hljs-comment">// 相当于 (*it).method();</span></span><br><span class="line">    <span class="hljs-comment">// 相当于 (&amp;(*it)) -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-like-classes-所谓-仿函数-像函数的类"><a href="#function-like-classes-所谓-仿函数-像函数的类" class="headerlink" title="function-like classes, 所谓 仿函数 (像函数的类)"></a>function-like classes, 所谓 仿函数 (像函数的类)</h2><blockquote><blockquote><p>() 函数调用操作符 function call<br>一般只要看到class内重载了()操作符，那他的用意就是想要变成一个function,其构造的对象称为函数对象<br>标准库中，仿函数会继承一些奇特的基类如：unary_function , binary_function</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 大小为零</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>, <span class="hljs-title">class</span> <span class="hljs-title">Result</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">identity</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> T&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> T&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-comment">// 重载了函数调用操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&gt; // 源代码暗示你给他一个 <span class="hljs-title">pair</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">select1st</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;Pair, typname Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Pair::first_type&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x.first;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">select2nd</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;Pair, typname Pair::second_type&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Pair::second_type&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x.second;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="hljs-comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="hljs-keyword">const</span> T1&amp; a, <span class="hljs-keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="hljs-comment">// 传参初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; p(<span class="hljs-string">'a'</span>,<span class="hljs-number">97</span>);</span><br><span class="line">    <span class="hljs-keyword">char</span> ch = select1st(p);</span><br><span class="line">    <span class="hljs-keyword">int</span> in  = select2nd(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="namespase-经验谈"><a href="#namespase-经验谈" class="headerlink" title="namespase 经验谈"></a>namespase 经验谈</h2><hr><blockquote><blockquote><p>避免命名冲突</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-comment">// ---------------------------------------------</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> jj01 &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_member_template</span><span class="hljs-params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125; <span class="hljs-comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span></span><br><span class="line">namespase jj02 &#123;</span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line">    <span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_template_param</span><span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125; <span class="hljs-comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ----------------------------------------------</span></span><br><span class="line"><span class="hljs-comment">// 可以将所有测试函数放在一个main里面执行</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    jj01::test_member_template();</span><br><span class="line">    jj02::test_template_param();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-template-模板类-泛型编程"><a href="#class-template-模板类-泛型编程" class="headerlink" title="class template, 模板类(泛型编程)"></a>class template, 模板类(泛型编程)</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Class</span> &#123;</span></span><br><span class="line">    T a;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function">T <span class="hljs-title">getA</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> a;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="function-template-函数模板"><a href="#function-template-函数模板" class="headerlink" title="function template, 函数模板"></a>function template, 函数模板</h2><blockquote><blockquote><p>编译器会对 function template 进行 实参推导 (augument deduction)</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stone</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    stone (<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> we)</span><br><span class="line">    : _w(w), _h(h), _weight(we) &#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> stone&amp; ths) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> _weight &lt; rhs._weight;&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> _w, _h, _weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">min</span>(<span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">a</span>, <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">b</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">return</span> b &lt; a ? b : a; <span class="hljs-comment">// 实参推导的结果，T 为stone，于是调用 stone::operator&lt;()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="member-template-成员模板-令构造函数更有弹性"><a href="#member-template-成员模板-令构造函数更有弹性" class="headerlink" title="member template, 成员模板(令构造函数更有弹性)"></a>member template, 成员模板(令构造函数更有弹性)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="hljs-comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="hljs-keyword">const</span> T1&amp; a, <span class="hljs-keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="hljs-comment">// 传参初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 成员模板(是成员又是模板)</span></span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U1</span>, <span class="hljs-title">class</span> <span class="hljs-title">U2</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-title">pair</span>(<span class="hljs-title">const</span> <span class="hljs-title">pair</span>&lt;U1, U2&gt;&amp; <span class="hljs-title">p</span>) // 构造函数 <span class="hljs-title">U1</span>,<span class="hljs-title">U2</span> 必须(可转型为)继承于 <span class="hljs-title">T1</span>,<span class="hljs-title">T2</span></span></span><br><span class="line"><span class="hljs-class">    :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived1</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived2</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p); <span class="hljs-comment">// 可以</span></span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; b;</span><br><span class="line">pair&lt;Derived1, Derived2&gt; b2(b); <span class="hljs-comment">// 不可以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_ptr</span> :</span> <span class="hljs-keyword">public</span> __shared_ptr&lt;_Tp&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(_Tp1* __p)</span></span></span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base1* ptr = <span class="hljs-keyword">new</span> Derived1; <span class="hljs-comment">// up-cast 向上造型</span></span><br><span class="line"><span class="hljs-built_in">shared_ptr</span>&lt;Base1&gt; sptr(<span class="hljs-keyword">new</span>  Derived1); <span class="hljs-comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure><h2 id="specialization-模板特化"><a href="#specialization-模板特化" class="headerlink" title="specialization, 模板特化"></a>specialization, 模板特化</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 泛化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>&gt; // 绑定</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">hash</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">char</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">int</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; hash&lt;<span class="hljs-keyword">int</span>&gt; () (<span class="hljs-number">1000</span>); <span class="hljs-comment">// 临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partial-specialization-模板偏特化-–-个数上的偏"><a href="#partial-specialization-模板偏特化-–-个数上的偏" class="headerlink" title="partial specialization, 模板偏特化 – 个数上的偏"></a>partial specialization, 模板偏特化 – 个数上的偏</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 泛化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = ...&gt;</span><br><span class="line">class <span class="hljs-built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 偏特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>, Alloc&gt; <span class="hljs-comment">// 绑定第一个模板参数，必须从左到右依次指定，不可跳跃</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// --------------------------------------------</span></span><br><span class="line"><span class="hljs-comment">// 范围上的偏特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="hljs-built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="hljs-built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></figure><h2 id="template-template-parameter-模板模板参数"><a href="#template-template-parameter-模板模板参数" class="headerlink" title="template template parameter, 模板模板参数"></a>template template parameter, 模板模板参数</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"> <span class="hljs-comment">// Container为模板模板参数</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> &gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCls</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">list</span>&gt; my1st1; <span class="hljs-comment">// Error list本身是模板，未定义</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, Lst&gt; my1st2; <span class="hljs-comment">// 可以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmatPtr</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCls</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    SmatPtr&lt;T&gt; sp;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    XCls() : sp(<span class="hljs-keyword">new</span> T) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">shared_ptr</span>&gt; p1; <span class="hljs-comment">// ok</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unique_ptr</span>&gt; p2; <span class="hljs-comment">// no</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, weak_ptr&gt; p3; <span class="hljs-comment">// no</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">auto_ptr</span>&gt; p4; <span class="hljs-comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="这个不是-template-template-parameter"><a href="#这个不是-template-template-parameter" class="headerlink" title="这个不是 template template parameter"></a>这个不是 template template parameter</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> = <span class="hljs-title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">stack</span> &#123;</span></span><br><span class="line">    pass</span><br><span class="line"><span class="hljs-keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1;</span><br><span class="line"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; s2; <span class="hljs-comment">// 已经指定list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于-C-标准库"><a href="#关于-C-标准库" class="headerlink" title="关于 C++ 标准库"></a>关于 C++ 标准库</h2><hr><blockquote><blockquote><p>Iterator   迭代器<br>Container  容器<br>Algorithm  算法<br>Functors   仿函数</p></blockquote></blockquote><p>查看标准库，并实验每一个已经实现的标准库功能。</p><hr><h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++11 新特性"></a>C++11 新特性</h1><hr><h2 id="variadic-templates-数量不定的模板参数-since-C-11"><a href="#variadic-templates-数量不定的模板参数-since-C-11" class="headerlink" title="variadic templates  数量不定的模板参数 (since C++11)"></a>variadic templates  数量不定的模板参数 (since C++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// ... 也是语法的一部分</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg, <span class="hljs-keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// &lt;&lt; 须重载</span></span><br><span class="line">    print(args...); <span class="hljs-comment">// 递归调用，每次分为firstArg和后面 Types... (其他的多个)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 调用</span></span><br><span class="line">print(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">337</span>), <span class="hljs-number">42</span>);</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">7.5</span></span><br><span class="line"><span class="hljs-comment">hello</span></span><br><span class="line"><span class="hljs-comment">0000000101111001</span></span><br><span class="line"><span class="hljs-comment">42</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 通过 sizeof(args...) 可以得到后面一包是几个</span></span><br></pre></td></tr></table></figure><h2 id="auto-语法糖-since-c-11"><a href="#auto-语法糖-since-c-11" class="headerlink" title="auto 语法糖(since c++11)"></a>auto 语法糖(since c++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; c;</span><br><span class="line"><span class="hljs-keyword">auto</span> ite = find(c.begin(), c.end(), target); </span><br><span class="line"><span class="hljs-comment">// 让编译器自动帮你推断类型，但前提是你得有assign语句，不然编译器不知道怎么推</span></span><br><span class="line"><span class="hljs-keyword">auto</span> it; <span class="hljs-comment">// 不能这样写，编译器不知道it是什么类型</span></span><br><span class="line">it = find(c.begin(), c.end(),target); <span class="hljs-comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="range-base-for-语法糖-since-C-11"><a href="#range-base-for-语法糖-since-C-11" class="headerlink" title="range-base for 语法糖(since C++11)"></a>range-base for 语法糖(since C++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : container) <span class="hljs-comment">// 逐个取出，copy到 i 上 (pass by value)</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : container) <span class="hljs-comment">// pass by reference 更改了container 中的值</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;) <span class="hljs-comment">// 新语法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference-引用-代表-实际上是指针实现的"><a href="#reference-引用-代表-实际上是指针实现的" class="headerlink" title="reference 引用(代表),实际上是指针实现的"></a>reference 引用(代表),实际上是指针实现的</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span>* p = &amp;x; <span class="hljs-comment">// p pointer to x</span></span><br><span class="line"><span class="hljs-keyword">int</span>&amp; r = x;  <span class="hljs-comment">// r reference to x , r 代表 x, r 从一而终，不能再代表其它对象了</span></span><br><span class="line"><span class="hljs-keyword">int</span> x2 = <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 编译器制造的假象</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">sizeof</span>(r) == <span class="hljs-keyword">sizeof</span>(x)) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true 但其实 r 是一个指针</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; (&amp;r == &amp;x) &lt;&lt; <span class="hljs-built_in">endl</span>;               <span class="hljs-comment">// true 假象</span></span><br><span class="line"></span><br><span class="line">r = x2;      <span class="hljs-comment">// r 不能从新代表其它对象，只是把 r 代表的 x 的值变成 x2 的值罢了</span></span><br><span class="line"><span class="hljs-keyword">int</span>&amp; r2 = r; <span class="hljs-comment">// r2 reference to r (r2 代表 r, 亦相当于代表 x)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 不管是内置类型还是自定义类型都符合上述结论</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>reference 通常不用于声明变量，而用于参数类型(parameter type)和返回类型(return type)的描述.</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T *pobj)</span> </span>&#123;pobj -&gt; xxx();&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T pobj)</span> </span>&#123;pobj.xxx();&#125; <span class="hljs-comment">// 须拷贝，传递较慢</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(T&amp; pobj)</span> </span>&#123;pobj.xxx();&#125;</span><br><span class="line"></span><br><span class="line">T obj;</span><br><span class="line">func1(&amp;obj);<span class="hljs-comment">// 调用接口不同，困扰</span></span><br><span class="line">func2(obj); <span class="hljs-comment">// 调用接口相同，很好</span></span><br><span class="line">func3(obj);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 特别注意，写函数重载时，以下两种(same signature)不能并存</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> im)</span></span>; <span class="hljs-comment">// Ambiguous</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Q : const 是不是函数签名的一部分，即是否能作为重载的指标？<br>A : 是！</p></blockquote></blockquote><h1 id="Object-Model-对象模型"><a href="#Object-Model-对象模型" class="headerlink" title="Object Model 对象模型"></a>Object Model 对象模型</h1><hr><h2 id="Part-I-的承接"><a href="#Part-I-的承接" class="headerlink" title="Part I 的承接"></a>Part I 的承接</h2><blockquote><blockquote><p>Inheritance 继承：           构造由内而外，析构由外而内<br>Composition 复合：           构造由内而外，析构由外而内<br>Inheritance+Composition：    构造由内而外，析构由外而内</p><blockquote><p>Derived::Derived(…) : Base(),Component() {…}<br>Derived::~Derived() {… Component(); Base()} // 与构造相反</p></blockquote></blockquote></blockquote><h2 id="关于-vptr-和-vtbl-虚指针和虚表"><a href="#关于-vptr-和-vtbl-虚指针和虚表" class="headerlink" title="关于 vptr 和 vtbl (虚指针和虚表)"></a>关于 vptr 和 vtbl (虚指针和虚表)</h2><blockquote><blockquote><p>只要类中有虚函数，其对象在内存中就会多一根指针（指向虚表）<br>父类有虚函数，子类对象也一定拥有该指针</p></blockquote></blockquote><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A &#123;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">public</span> B &#123;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内存模型：-动态绑定"><a href="#内存模型：-动态绑定" class="headerlink" title="内存模型： 动态绑定"></a>内存模型： 动态绑定</h3><hr><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr.jpg" alt="内存模型"></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">C *p = <span class="hljs-keyword">new</span> C;</span><br><span class="line">(*p).vfunc2();</span><br><span class="line"><span class="hljs-comment">// 相当于,其中 n 表示虚表中的第 n 个虚函数</span></span><br><span class="line">(*(p-&gt;vptr)[n])(p);</span><br><span class="line">(* p-&gt;vptr[n] )(p);</span><br></pre></td></tr></table></figure><hr><h3 id="应用：PPT-图形类-多态的应用"><a href="#应用：PPT-图形类-多态的应用" class="headerlink" title="应用：PPT 图形类(多态的应用)"></a>应用：PPT 图形类(多态的应用)</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr2.jpg" alt="PPT类"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>&emsp;C++ 编译器看到一个函数调用，会有两个考量（静态绑定，动态绑定)</p><ol><li>静态绑定是被编译成: CALL xxxx(func address)。</li><li>但如果符合某些条件就会动态绑定：<ul><li>通过指针调用</li><li>指针向上转型 up-cast</li><li>所调用的是虚函数(virtual func)<br>动态绑定的形式：虚机制<br>多态：指针具有很多的类型（型态）</li></ul></li></ol><hr><h2 id="关于-this-pointer"><a href="#关于-this-pointer" class="headerlink" title="关于 this pointer"></a>关于 this pointer</h2><blockquote><blockquote><p>设计分析继承体系时要对this pointer有一个清晰的认识<br>对象调用成员函数时，该对象的this指正就会隐含地传入函数中<br>下图中在对象调用OnFileOpen()时传入对象地址this，因此碰到虚函数Serialize()函数后，回去寻找CMyDoc类的虚函数表中的函数（动态绑定）</p></blockquote></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/templateMethod.jpg" alt=""></p><hr><h2 id="谈谈-const-const-member-function-常量成员函数"><a href="#谈谈-const-const-member-function-常量成员函数" class="headerlink" title="谈谈 const (const member function 常量成员函数)"></a>谈谈 const (const member function 常量成员函数)</h2><blockquote><p>const 是属于函数签名的一部分</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    Class() &#123;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> mem;&#125; <span class="hljs-comment">// 保证不更改 mem</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> mem;&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>const object(datamember不可变动)</th><th>non-const object(datamem可变动)</th></tr></thead><tbody><tr><td>const member functions(保证datamenber不变)</td><td>YES</td><td>YES</td></tr><tr><td>non-const member functions(不保证datamember不变)</td><td>无法调用</td><td>YES </td></tr></tbody></table><blockquote><p>当成员函数的 const 和 non-const 版本同时存在时，const Object 只会调用 const 版本，non-const Object 只会调用 non-const 版本</p></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/db.jpg" alt=""></p><hr><h2 id="关于-new-delete-array-new-array-delete-重载"><a href="#关于-new-delete-array-new-array-delete-重载" class="headerlink" title="关于 new , delete. array new , array delete.(重载)"></a>关于 new , delete. array new , array delete.(重载)</h2><h3 id="Part-I-承接："><a href="#Part-I-承接：" class="headerlink" title="Part I 承接："></a>Part I 承接：</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/new.png" alt=""></p><hr><h3 id="全局重载形式"><a href="#全局重载形式" class="headerlink" title="全局重载形式"></a>全局重载形式</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/overideDelete.jpg" alt=""></p><h3 id="成员重载形式"><a href="#成员重载形式" class="headerlink" title="成员重载形式"></a>成员重载形式</h3><blockquote><p>new 分解为 3 个动作<br>delete 分解为 2 个动作<br>接管内存的分配和释放的行为</p></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride.jpg" alt=""></p><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride%5B%5D.jpg" alt=""></p><hr><h3 id="示例，-接口"><a href="#示例，-接口" class="headerlink" title="示例， 接口"></a>示例， 接口</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __FOO__</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FOO__</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-keyword">int</span> _id;</span><br><span class="line"><span class="hljs-keyword">long</span> _data;</span><br><span class="line"><span class="hljs-built_in">string</span> _str;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">Foo() : _id(<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"default ctor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line">Foo(<span class="hljs-keyword">int</span> id) : _id(id) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ctor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//virtual    // 可选的 virtual 关键字</span></span><br><span class="line">~Foo() &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dtor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size);</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">Foo* p = (Foo*) <span class="hljs-built_in">malloc</span>(size);</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:new has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* phead,<span class="hljs-keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:delete has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">Foo* p = (Foo*) <span class="hljs-built_in">malloc</span>(size);</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:new[] has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:delete[] has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// END DEFINE</span></span></span><br></pre></td></tr></table></figure><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"sizeof(Foo) = "</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Foo) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Foo *p = <span class="hljs-keyword">new</span> Foo(<span class="hljs-number">7</span>);</span><br><span class="line"><span class="hljs-keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"============================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Foo* pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-keyword">delete</span>[] pArray;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"********************************************"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 强制全局,不会进入重载函数</span></span><br><span class="line">Foo* _p = ::<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">7</span>);</span><br><span class="line">::<span class="hljs-keyword">delete</span>[] _p;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"============================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 强制全局</span></span><br><span class="line">Foo *_pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];</span><br><span class="line">::<span class="hljs-keyword">delete</span>[] _pArray;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foo.png" alt="Foo with non-virtual dtor"></p><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foowithvirtual.png" alt="Foo with virtual dtor"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;还没有整理过的笔记，有点乱&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://www.ccyh.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="https://www.ccyh.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode23 合并 K 个排序链表(Hard)</title>
    <link href="https://www.ccyh.xyz/p/fb7f.html"/>
    <id>https://www.ccyh.xyz/p/fb7f.html</id>
    <published>2019-09-10T13:43:26.000Z</published>
    <updated>2020-05-06T09:06:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>&emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><a id="more"></a><p><strong>示例:</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,</span><br><span class="line">  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,</span><br><span class="line">  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>&emsp;因为所给链表均有序且头节点指针均在一个数组中，可以将当前数组中的头节点指针所指向的链表节点的值与其所在下标绑定为一个 pair 并存入一个最小堆中（按节点val排序，由优先级队列实现），这样就可以每次从堆中（pop）取出最小值用尾插法插入结果链表中。并且每次pop后都更新lists数组，将新的头节点的 pair 推入最小堆中，如此循环往复直至堆为空。</p><h3 id="算法演示："><a href="#算法演示：" class="headerlink" title="算法演示："></a>算法演示：</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/lists.PNG" alt="lists数组"><br></center><p>I. 初始化堆：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; Q;</span><br><span class="line"><span class="hljs-comment">//初始化优先级队列，将lists中的元素下标与其所指链表节点的val绑定为pair入堆</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="hljs-comment">//加负号取反，间接实现小顶堆</span></span><br><span class="line">                      Q.push(make_pair(-lists[i]-&gt;val,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/Initial.PNG" alt=""><br></center><p>II. 从堆中取出最小元素（堆顶）并更新lists数组与堆</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"> <span class="hljs-comment">//实现摘下链表头节点的操作(跟新lists)</span></span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(-Q.top().first);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line"><span class="hljs-keyword">int</span> i = Q.top().second;</span><br><span class="line">ListNode *r = lists[Q.top().second];</span><br><span class="line">lists[Q.top().second] = lists[Q.top().second] -&gt; next;</span><br><span class="line"><span class="hljs-keyword">delete</span>(r);<span class="hljs-comment">//释放内存</span></span><br><span class="line"> <span class="hljs-comment">//弹出顶点</span></span><br><span class="line">Q.pop();</span><br><span class="line"><span class="hljs-comment">//新头节点进入</span></span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val, i));</span><br></pre></td></tr></table></figure><center><br>1. 更新lists数组<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/reLists.PNG" alt="更新lists"><br>2. 弹出堆顶<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/pop1.PNG" alt="弹出顶点"><br>3. 更新堆<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/push1.PNG" alt="更新堆"><br></center><p>III. 循环II（1、2、3）直到堆为空。</p><hr><h2 id="算法代码："><a href="#算法代码：" class="headerlink" title="算法代码："></a>算法代码：</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//定义优先级队列，对pair默认对第一个元素按从小到大排序（大顶堆）</span></span><br><span class="line"><span class="hljs-comment">//因此push进队列时可将对应链表节点的val值取相反数，输出时还原，间接实现了小顶堆</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; Q;</span><br><span class="line"><span class="hljs-comment">//初始化优先级队列，将lists中的元素下标与</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义结果链表头节点</span></span><br><span class="line">ListNode *head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>),*p = head;</span><br><span class="line"><span class="hljs-keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//实现摘下链表头节点的操作</span></span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(-Q.top().first);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line"><span class="hljs-keyword">int</span> i = Q.top().second;</span><br><span class="line">ListNode *r = lists[Q.top().second];</span><br><span class="line">lists[Q.top().second] = lists[Q.top().second] -&gt; next;</span><br><span class="line"><span class="hljs-keyword">delete</span>(r);</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> head -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//生成链表数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generatList</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-built_in">list</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>.size()!=lists.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* p = lists[i];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">list</span>[i].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) &#123; lists[i] = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-built_in">list</span>[i][j]); p = lists[i];&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-built_in">list</span>[i][j]);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;ListNode*&gt; lists(<span class="hljs-number">3</span>);</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">list</span> = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;&#125;;</span><br><span class="line">generatList(lists,<span class="hljs-built_in">list</span>);</span><br><span class="line">ListNode* head = mergeKLists(lists);</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="hljs-keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; p -&gt; val &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/result23.PNG" alt=""><br></center><hr><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><p>&emsp;假设 K 个链表每个链表的长度为 N ，堆的调整时间复杂度为 $ \log_{2}{K} $，故时间复杂度为$ KN \log_{2}{K} $.<br>&emsp;空间复杂度为$ O(1) $.</p><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;&amp;emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1178_Hard_猜字谜</title>
    <link href="https://www.ccyh.xyz/p/d850.html"/>
    <id>https://www.ccyh.xyz/p/d850.html</id>
    <published>2019-09-06T12:30:03.000Z</published>
    <updated>2020-05-06T09:06:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><a id="more"></a><p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 word 中包含谜面 puzzle 的第一个字母。</li><li>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。<br>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。<br><strong> 示例：</strong><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [<span class="hljs-string">"aaaa"</span>,<span class="hljs-string">"asas"</span>,<span class="hljs-string">"able"</span>,<span class="hljs-string">"ability"</span>,<span class="hljs-string">"actt"</span>,<span class="hljs-string">"actor"</span>,<span class="hljs-string">"access"</span>], </span><br><span class="line">puzzles = [<span class="hljs-string">"aboveyz"</span>,<span class="hljs-string">"abrodyz"</span>,<span class="hljs-string">"abslute"</span>,<span class="hljs-string">"absoryz"</span>,<span class="hljs-string">"actresz"</span>,<span class="hljs-string">"gaswxyz"</span>]</span><br><span class="line">输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">"aboveyz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span> </span><br><span class="line"><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">"abrodyz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span></span><br><span class="line"><span class="hljs-number">3</span> 个单词可以作为 <span class="hljs-string">"abslute"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span>, <span class="hljs-string">"able"</span></span><br><span class="line"><span class="hljs-number">2</span> 个单词可以作为 <span class="hljs-string">"absoryz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span></span><br><span class="line"><span class="hljs-number">4</span> 个单词可以作为 <span class="hljs-string">"actresz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span>, <span class="hljs-string">"actt"</span>, <span class="hljs-string">"access"</span></span><br><span class="line">没有单词可以作为 <span class="hljs-string">"gaswxyz"</span> 的谜底，因为列表中的单词都不含字母 <span class="hljs-string">'g'</span>。</span><br></pre></td></tr></table></figure></li></ul><p><strong> 提示： </strong></p><blockquote><ul><li>1 &lt;= words.length &lt;= 10^5</li><li>4 &lt;= words[i].length &lt;= 50</li><li>1 &lt;= puzzles.length &lt;= 10^4</li><li>puzzles[i].length == 7</li><li>words[i][j], puzzles[i][j] 都是小写英文字母。</li><li>每个 puzzles[i] 所包含的字符都不重复。</li></ul></blockquote><hr><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h3 id="法一：暴力枚举判断（超时）"><a href="#法一：暴力枚举判断（超时）" class="headerlink" title="法一：暴力枚举判断（超时）"></a>法一：暴力枚举判断（超时）</h3><p>这个算法很直观，无非就是遍历枚举每一个谜面，判断words中能作为它的谜底的word的个数。<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfVaildWords(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> charcounter[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">&#123;</span><br><span class="line">charcounter[j-<span class="hljs-string">'a'</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k : words)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; chset;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m : k)</span><br><span class="line">&#123;</span><br><span class="line">chset.insert(m);</span><br><span class="line"><span class="hljs-keyword">if</span>(chset.size()&gt;<span class="hljs-number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(chset.find(i[<span class="hljs-number">0</span>])==chset.end())</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">auto</span> iter = chset.begin();</span><br><span class="line"><span class="hljs-keyword">bool</span> flags = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(;iter != chset.end();iter++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(charcounter[(*iter)-<span class="hljs-string">'a'</span>] &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flags = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flags) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="法二：暴力枚举-位运算（超时）"><a href="#法二：暴力枚举-位运算（超时）" class="headerlink" title="法二：暴力枚举+位运算（超时）"></a>法二：暴力枚举+位运算（超时）</h3><p>已知int行为32位，而小写字母有26个，因此用一个int型的整数就能够表示字符串中是否出现某字符：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode1178.PNG" alt=""><br></center><p>上图就可以表示字符串“anwvw”<br>因此思路就是沿用上面的暴力枚举方法，只不过将字符串查询比较转化为整数的比较。</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfVaildWords_BTL(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; binOfpuzzles;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//生成谜面的二进制数</span></span><br><span class="line"><span class="hljs-keyword">int</span> puzzle = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">&#123;</span><br><span class="line">puzzle = puzzle | (<span class="hljs-number">1</span> &lt;&lt; (j-<span class="hljs-string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line">binOfpuzzles.push_back(puzzle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; binOfwords;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; k : words)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//生成谜底的二进制数</span></span><br><span class="line"><span class="hljs-keyword">int</span> word = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; m : k)</span><br><span class="line">&#123;</span><br><span class="line">word = word | (<span class="hljs-number">1</span> &lt;&lt; (m-<span class="hljs-string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line">binOfwords.push_back(word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : binOfpuzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; j : binOfwords)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(i == j) ans++;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((((<span class="hljs-number">1</span> &lt;&lt; (puzzles[n][<span class="hljs-number">0</span>]-<span class="hljs-string">'a'</span>)) &amp; j) != <span class="hljs-number">0</span>)) <span class="hljs-comment">//如果word中包含puzz的第一个字母</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">26</span>;k++) <span class="hljs-comment">//判断是否符合第二条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>( ((<span class="hljs-keyword">int</span>)((<span class="hljs-number">1</span> &lt;&lt; k)&amp;i) == <span class="hljs-number">0</span>) &amp;&amp; ((<span class="hljs-keyword">int</span>)((<span class="hljs-number">1</span> &lt;&lt; k)&amp;j) != <span class="hljs-number">0</span>) ) <span class="hljs-comment">//word中存在而puzz中不存在</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flag) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(ans);</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法虽然比第一个好点但是当面对更大规模的测试样例时还是会超时。</p><hr><h3 id="法三：位运算-哈希"><a href="#法三：位运算-哈希" class="headerlink" title="法三：位运算+哈希"></a>法三：位运算+哈希</h3><p>分析题设，根据第一个成为谜底的条件就是word中必须包含puzzle中的第一个字符，因此可以建立26个字符与包含该字符的word的整数表示所组成的数组的映射关系：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode11782.PNG" alt=""><br></center><p>如此一来，我们就只需判断包含puzzle首字符的word是否是谜底就可以了，减少了很多无用重复的比较。<br>再者，不难发现若某一个word是puzzle的谜底那么其包含的字符种类肯定小于等于puzzle所包含的字符种类，这体现在整数化的字符串中就是：intOfWord的二进制值中 1 的位数肯定少于或等于intOfPuzzle中 1 的位数，并且intOfWord中 1 出现的位必将也是intOfPuzzle中 1 出现的位。因此对intOfWord和intOfPuzzle取余就会得到它们共同拥有的字符的字符串的整数表示，若该结果等与intOfWord就表明此时的word就是谜底。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode11783.PNG" alt=""><br></center><p><strong> 最终算法如下：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfValidWords(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles) &#123;</span><br><span class="line"><span class="hljs-comment">//v用来保存含有'a'+i字母的word的二进制数</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; hashV[<span class="hljs-number">26</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : words) &#123;</span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; s(i.begin(), i.end());</span><br><span class="line"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//生成一个谜底word的二进制数</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">26</span>; ii++)</span><br><span class="line"><span class="hljs-keyword">if</span> (s.count(<span class="hljs-string">'a'</span> + ii))</span><br><span class="line">tmp = tmp^(<span class="hljs-number">1</span> &lt;&lt; ii);</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> j : s)</span><br><span class="line">hashV[j - <span class="hljs-string">'a'</span>].push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//结果数组ans</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : puzzles) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> at = i[<span class="hljs-number">0</span>] - <span class="hljs-string">'a'</span>;<span class="hljs-comment">//记录首字母</span></span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; s(i.begin(), i.end());</span><br><span class="line"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//生成一个谜面的二进制数</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">26</span>; ii++)</span><br><span class="line"><span class="hljs-keyword">if</span> (s.count(<span class="hljs-string">'a'</span> + ii))</span><br><span class="line">tmp ^= <span class="hljs-number">1</span> &lt;&lt; ii;</span><br><span class="line">ans.push_back(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : hashV[at]) <span class="hljs-comment">//hashV[at]中保存的是包含puzzle首字母的word的二进制数</span></span><br><span class="line"><span class="hljs-keyword">if</span> ((j &amp; tmp) == j) <span class="hljs-comment">//j &amp; tmp 会得到它们共同拥有的字符的二进制数，</span></span><br><span class="line">ans.back()++;   <span class="hljs-comment">//若其值与(j)不相等则表示word中含有puzzle中不含的字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="运行测试："><a href="#运行测试：" class="headerlink" title="运行测试："></a>运行测试：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; words = &#123;<span class="hljs-string">"aaaa"</span>,<span class="hljs-string">"asas"</span>,<span class="hljs-string">"able"</span>,<span class="hljs-string">"ability"</span>,<span class="hljs-string">"actt"</span>,<span class="hljs-string">"actor"</span>,<span class="hljs-string">"access"</span>&#125;;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; puzzles = &#123;<span class="hljs-string">"aboveyz"</span>,<span class="hljs-string">"abrodyz"</span>,<span class="hljs-string">"abslute"</span>,<span class="hljs-string">"absoryz"</span>,<span class="hljs-string">"actresz"</span>,<span class="hljs-string">"gaswxyz"</span>&#125;;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res(findNumOfValidWords(words,puzzles));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"  "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode1178res.PNG" alt=""><br></center><hr><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
</feed>
